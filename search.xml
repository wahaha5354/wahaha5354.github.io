<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python数据类型之数字和字符串]]></title>
    <url>%2F2018%2F12%2F13%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[python数据类型： Number（数字） String(字符串) List(列表) Dictonary（字典） Tuple(元组) sets(集合) 其中数字、字符串、元组是不可变的，列表、字典是可变的。对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象（如果没有其他变量引用原有对象的话（即引用计数为0），原有对象就会被回收）。 数字 int:整数 &amp;ensp;&amp;ensp; 1.正负数 &amp;ensp; &amp;ensp;2.十六进制(表示方式为0x或者0X开头。例如：0xff) &amp;ensp; &amp;ensp;3.八进制(表示方式为0o或者0O开头。例如：0o632457) &amp;ensp;&amp;ensp; 4.二进制 (表示方式为0b或者0B开头。例如：0b101100) fraction:分数 float:浮点数 complex:复数 bool:布尔型(特殊的数值类型，只有True和False两个值)进制转换整数转其他进制使用bin(i),oct(i),hex(i)函数可以将十进制数分别转换为二进制，八进制，十六进制1234567&gt;&gt;&gt; s=10&gt;&gt;&gt; bin(s)'0b1010'&gt;&gt;&gt; oct(s)'0o12'&gt;&gt;&gt; hex(s)'0xa' 使用int(str,base)可以将非十进制的数转换成整数，其中str是文本形式的数字，base可以为2,8,16数字，分别代表二进制，八进制，十六进制，最高到36位，最低为212345678910 &gt;&gt;&gt; int('0b10010',2)18&gt;&gt;&gt; int('0o52415',8)21773&gt;&gt;&gt; int('0x134ab',16)79019&gt;&gt;&gt; int('s',32)28&gt;&gt;&gt; int('yz',36)1259 当然也可以进行16进制转二进制八进制，八进制可以转其他进制123456789101112&gt;&gt;&gt; hex(0b1001)'0x9'&gt;&gt;&gt; hex(0o1234)'0x29c'&gt;&gt;&gt; oct(0b101)'0o5'&gt;&gt;&gt; oct(0xff)'0o377'&gt;&gt;&gt; bin(0xff)'0b11111111'&gt;&gt;&gt; bin(0o7777)'0b111111111111' 各类运算符 算数运算符：+,-,*,/,%.//,** 比较运算符：==，!=,&gt;,&lt;,&lt;=,&gt;= 赋值运算符：=,+=,-=,*=,/=,%=,//=.**= 位运算符：&amp;,|,^,~,&lt;&lt;,&gt;&gt; 逻辑运算符：and,or,not 成员运算符：in,not in 身份运算符：is,is not12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=12&gt;&gt;&gt; f=~a&gt;&gt;&gt; f-13&gt;&gt;&gt; bin(f)'-0b1101'&gt;&gt;&gt; bin(a)'0b1100'&gt;&gt;&gt; bin(a&lt;&lt;1)'0b11000'&gt;&gt;&gt; bin(a&gt;&gt;1)'0b110'&gt;&gt;&gt; list=[1,2,3,4,5]&gt;&gt;&gt; a=3&gt;&gt;&gt; print (a in list)True&gt;&gt;&gt; print (a not in list)False&gt;&gt;&gt; a=['1,2,3,4,5']&gt;&gt;&gt; b=a&gt;&gt;&gt; print (b is a )True&gt;&gt;&gt; print (b is not a )False&gt;&gt;&gt; b=a[:]&gt;&gt;&gt; print (b is a) #这是因为字符串是不可变的False&gt;&gt;&gt; print (id(a))42473480&gt;&gt;&gt; print (id(b))42485000 运算符优先级 ** （优先级最高的是幂运算） ~,+,- (加和减都是一元运算符) *，/，%，// +,- &lt;&lt;,&gt;&gt; &amp; ^,| &lt;=,&gt;=,&lt;,&gt; ==,!= =,+=,-=,*=,/=,%=,//=,**=数学函数的应用 power：幂函数，功能与运算符**一样 12&gt;&gt;&gt; pow(2,3)8 sqrt：取当前数的平方根 123&gt;&gt;&gt; import math&gt;&gt;&gt; math.sqrt(4)2.0 max：最大值 12&gt;&gt;&gt;max(2,3,4,5,1,9,6)9 min：最小值 12&gt;&gt;&gt; min(2,3,4,5,1,9,6)1 abs与fabs：取绝对值，fabs取出的是浮点数 1234&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; math.fabs(-1)1.0 round：四舍五入（当小数为5的时候会向靠近偶数的一端进） 12345678&gt;&gt;&gt; round(3.5)4&gt;&gt;&gt; round(2.5)2&gt;&gt;&gt; round(2.54)3&gt;&gt;&gt; round(2.45)2 ceil：向上取整 1234&gt;&gt;&gt; math.ceil(1.7)2&gt;&gt;&gt; math.ceil(1.3)2 floor：向下取整 1234&gt;&gt;&gt; math.floor(1.7)1&gt;&gt;&gt; math.floor(1.3)1 cmp：python2中的比较函数，当前面数值大返回-1，一样大返回0，后面数值大返回1 123456&gt;&gt;&gt; cmp(1,2)-1&gt;&gt;&gt; cmp(1,1)0&gt;&gt;&gt; cmp(2,1)1 随机数函数&ensp;&ensp;- 取0-1之间的随机小数： 123&gt;&gt;&gt; import random&gt;&gt;&gt; random.random()0.18001643527271916 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 取自定义数里的随机数：(可以取多个元素)12345678&gt;&gt;&gt; random.choice([1,2,3,4,5])2&gt;&gt;&gt; random.choice([1,2,3,4,5])3&gt;&gt;&gt; random.sample([1,2,3,4,5,6,7,8,9],2)[3, 7]&gt;&gt;&gt; random.sample([1,2,3,4,5,6,7,8,9],3)[4, 9, 3] &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 随机打乱顺序：1234&gt;&gt;&gt; a=[1,2,3,4,5,8]&gt;&gt;&gt; random.shuffle(a)&gt;&gt;&gt; a[1, 8, 2, 3, 4, 5] &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 获取N位随机数：(二进制)123456&gt;&gt;&gt; random.getrandbits(6)55&gt;&gt;&gt; random.getrandbits(6)48&gt;&gt;&gt; random.getrandbits(7)104 modf：把浮点数的整数位和小数位单独取出来 12345678&gt;&gt;&gt; math.modf(1.4)(0.3999999999999999, 1.0)&gt;&gt;&gt; math.modf(1.5)(0.5, 1.0)&gt;&gt;&gt; math.modf(2.8)(0.7999999999999998, 2.0)&gt;&gt;&gt; math.modf(3.1)(0.10000000000000009, 3.0) log：指数函数。默认e为底数，结果为浮点数。也可以自定义底数 12345678&gt;&gt;&gt; math.log(4,2)2.0&gt;&gt;&gt; math.log2(4)2.0&gt;&gt;&gt; math.log10(100)2.0&gt;&gt;&gt; math.log(100,10)2.0 格式化输出：格式化输出保留有效数字,格式化输出的是字符串 12345678&gt;&gt;&gt; s=format(2.345,'0.2f')&gt;&gt;&gt; s&gt;&gt;&gt; type (s)&lt;class 'str'&gt;&gt;&gt;&gt; round(2.5)2&gt;&gt;&gt; format(2.5,'0.0f')'2' Decimal模块：在使用浮点数的时候，因为计算机是使用二进制表示，所以会出现精度问题，可以使用Deciamal模块来解决精度问题 123456789&gt;&gt;&gt; a=4.2&gt;&gt;&gt; b=2.1&gt;&gt;&gt; a+b6.300000000000001&gt;&gt;&gt; from decimal import Decimal&gt;&gt;&gt; a=Decimal('2.1')&gt;&gt;&gt; b=Decimal('4.2')&gt;&gt;&gt; a+bDecimal('6.3') 格式化输出——format：使用format进行进制转换 12345678910111213&gt;&gt;&gt; a=20&gt;&gt;&gt; bin(a)'0b10100'&gt;&gt;&gt; oct(a)'0o24'&gt;&gt;&gt; hex(a)'0x14'&gt;&gt;&gt; format(a,'b')'10100'&gt;&gt;&gt; format(a,'o')'24'&gt;&gt;&gt; format(a,'x')'14' 字符串字符串(python2默认使用ascii编码，使用Unicode编码须在字符串前加u,python3使用unicode编码）a=’str’a=u’str’ 字符串表示方法 单引号：’str’ ‘1’ 双引号：”str””1” 三引号：’’’…str…’’’ “””…str…””” 转义字符：“str1 \tadded tab\nstr2” Raw字符串：r”C:\user\administrator”(无法进行转义操作)字符串操作字符串合并12345678910 &gt;&gt;&gt; 'abc'+'def''abcdef'&gt;&gt;&gt; 'hello' *5'hellohellohellohellohello'&gt;&gt;&gt; print ('-'*50)--------------------------------------------------&gt;&gt;&gt; "aa""bb"'aabb'&gt;&gt;&gt; 'ab''cd''abcd' 字符串取值1234567891011121314151617181920212223242526a="text"&gt;&gt;&gt; for c in a:... print (c,end='')...text&gt;&gt;&gt; for c in a:... print (c,end='-')...t-e-x-t-&gt;&gt;&gt; 'x' in aTrue&gt;&gt;&gt; text='this_is_str'&gt;&gt;&gt; text[0:4]'this'&gt;&gt;&gt; text[5:7]'is'&gt;&gt;&gt; text[:4]'this'&gt;&gt;&gt; text[-3:]'str'&gt;&gt;&gt; text[-12:-7]'this'&gt;&gt;&gt; text[::2]'ti_ssr'&gt;&gt;&gt; text[8:1:-2]'ss_i' 字符串编码转换12345678&gt;&gt;&gt; ord(&apos;d&apos;)100&gt;&gt;&gt; chr(99)&apos;c&apos;&gt;&gt;&gt; ord(&apos;王&apos;)29579&gt;&gt;&gt; chr(29579)&apos;王&apos; 字符串大小写转换 这里利用ascii编码进行大小写转换 1234567891011121314151617181920&gt;&gt;&gt; Text=&quot;&quot; #初始化Text&gt;&gt;&gt; text=&quot;aSdFgHjK&quot; &gt;&gt;&gt; for i in text:... i_code=ord(i)... if 97&lt;=i_code and i_code&lt;=122:... Text+=chr(i_code-32)... else:... Text+=i...&gt;&gt;&gt; Text&apos;ASDFGHJK&apos;&gt;&gt;&gt; for x in text:... x_code=ord(x)... if 65&lt;=x_code and x_code&lt;=90:... Text+=chr(x_code+32)... else:... Text+=x...&gt;&gt;&gt; Text&apos;ASDFGHJKasdfghjk&apos; 这里利用字符串的方法进行转换 123&gt;&gt;&gt; str=&apos;asdFGHzxcVBN&apos;&gt;&gt;&gt; str.replace(&apos;asd&apos;,&apos;ASD&apos;)&apos;ASDFGHzxcVBN&apos; 除此之外，还可以使用字符串的大小写方法进行大小写转换 ascii编码对照表二进制 | 十进制 |十六进制 |图形|—|—|—|—|0010 0000|32|20|（空格）0010 0001|33|21|!0010 0010|34|22|”0010 0011|35|23|#0010 0100|36|24|$0010 0101|37|25|%0010 0110|38|26|&amp;0010 0111|39|27|’’0010 1000|40|28|(0010 1001|41|29|)0010 1010|42|2A|*0010 1011|43|2B|+0010 1100|44|2C|,0010 1101|45|2D|-0010 1110|46|2E|.0010 1111|47|2F|/0011 0000|48|30|00011 0001|49|31|10011 0010|50|32|20011 0011|51|33|30011 0100|52|34|40011 0101|53|35|50011 0110|54|36|60011 0111|55|37|70011 1000|56|38|80011 1001|57|39|90011 1010|58|3A|:0011 1011|59|3B|;0011 1100|60|3C|&lt;0011 1101|61|3D|=0011 1110|62|3E|&gt;0011 1111|63|3F|?0100 0000|64|40|@0100 0001|65|41|A0100 0010|66|42|B0100 0011|67|43|C0100 0100|68|44|D0100 0101|69|45|E0100 0110|70|46|F0100 0111|71|47|G0100 1000|72|48|H0100 1001|73|49|I0100 1010|74|4A|J0100 1011|75|4B|K0100 1100|76|4C|L0100 1101|77|4D|M0100 1110|78|4E|N0100 1111|79|4F|O0101 0000|80|50|P0101 0001|81|51|Q0101 0010|82|52|R0101 0011|83|53|S0101 0100|84|54|T0101 0101|85|55|U0101 0110|86|56|V0101 0111|87|57|W0101 1000|88|58|X0101 1001|89|59|Y0101 1010|90|5A|Z0101 1011|91|5B|[0101 1100|92|5C|\0101 1101|93|5D|]0101 1110|94|5E|^0101 1111|95|5F|_0110 0000|96|60|`0110 0001|97|61|a0110 0010|98|62|b0110 0011|99|63|c0110 0100|100|64|d0110 0101|101|65|e0110 0110|102|66|f0110 0111|103|67|g0110 1000|104|68|h0110 1001|105|69|i0110 1010|106|6A|j0110 1011|107|6B|k0110 1100|108|6C|l0110 1101|109|6D|m0110 1110|110|6E|n0110 1111|111|6F|o0111 0000|112|70|p0111 0001|113|71|q0111 0010|114|72|r0111 0011|115|73|s0111 0100|116|74|t0111 0101|117|75|u0111 0110|118|76|v0111 0111|119|77|w0111 1000|120|78|x0111 1001|121|79|y0111 1010|122|7A|z0111 1011|123|7B|{0111 1100|124|7C||0111 1101|125|7D|}0111 1110|126|7E|~ 字符串方法字符串大小写相关的方法 capitalize()：字符串首字母大写 123&gt;&gt;&gt; str='hello world'&gt;&gt;&gt; str.capitalize()'Hello world' title()：字符串中单词的首字母大写 12&gt;&gt;&gt; str.title()'Hello World' upper()：字符串转换成大写 1234567&gt;&gt;&gt; str.upper()'HELLO WORLD'``` - lower()：字符串转换成小写```python&gt;&gt;&gt; str.lower()'hello world' swapcase()：字符串大小写互转 123&gt;&gt;&gt; str='HellO wORld'&gt;&gt;&gt; str.swapcase()'hELLo WorLD' 字符串排版相关的方法 center()：居中对齐 12345&gt;&gt;&gt; str='hello'&gt;&gt;&gt; str.center(11)' helloo '&gt;&gt;&gt; str.center(11,'_')'___helloo__' ljust()：居左对齐 1234&gt;&gt;&gt; str.ljust(11,'_')'helloo_____'&gt;&gt;&gt; str.ljust(11)'helloo rjust()：居右对齐 1234&gt;&gt;&gt; str.rjust(11)' hello'&gt;&gt;&gt; str.rjust(11,'_')'_____hello' expandtabs()：修改tab空格的个数 1234567 &gt;&gt;&gt; str='hello\tworld'&gt;&gt;&gt; print (str)hello world&gt;&gt;&gt; str.expandtabs(9)'hello world'&gt;&gt;&gt; str.expandtabs(4)'hello world' zfill()：将字符串扩充到指定长度，前面使用0填充 1234 &gt;&gt;&gt; str.zfill(20)'000000000hello\tworld' &gt;&gt;&gt; 'sad'.zfill(10)'0000000sad' strip()：删除字符串两边(左边lstrip或右边rstrip)的指定字符（默认为空格和换行符） 123456789101112 &gt;&gt;&gt; str=' hello world '&gt;&gt;&gt; str.strip()'hello world'&gt;&gt;&gt; str.lstrip()'hello world '&gt;&gt;&gt; str.rstrip()' hello world'&gt;&gt;&gt; str='hello,world'&gt;&gt;&gt; str.strip('h')'ello,world'&gt;&gt;&gt; str.strip('[held]')'o,wor' 字符串查找相关的方法 startswith(prefix[,start[,end]])/endswith(suffix[,start[,end]]) 判断是否以特定字符串开头或者结尾123456789101112131415161718192021&gt;&gt;&gt; str='hello,world'&gt;&gt;&gt; str.startswith('hello')True&gt;&gt;&gt; str.startswith('hello',0,5)True&gt;&gt;&gt; str.startswith('hello',1,5)False&gt;&gt;&gt; str.endswith('rld',8)True&gt;&gt;&gt; str.endswith('rld',9)False&gt;&gt;&gt; str.endswith('rld',8,11)True``` - count(sub[,start[,end]])：相应字符串在文本中的个数```python&gt;&gt;&gt; str='hello,world'&gt;&gt;&gt; str.count('l')3&gt;&gt;&gt; str.count('ll')1 find/rfind()：分别从字符串前后开始查找第一个匹配到的字符串的位置,找不到就返回-1 12345str='hello,world'&gt;&gt;&gt; str.find('l')2&gt;&gt;&gt; str.rfind('l')9 index/rindex()：与find方法类似，但是找不到会报错 123456789&gt;&gt;&gt; str.index('l')2&gt;&gt;&gt; str.rindex('l')9&gt;&gt;&gt; str.index('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; str.find('a') replace(old,new[,count])：替换字符串，count代表替换个数 1234&gt;&gt;&gt; str.replace('l','L')'heLLo,worLd'&gt;&gt;&gt; str.replace('l','L',1)'heLlo,world' 格式判断相关方法 isalpha() ：判断是否是字母 isdigit()：判断是否是数字 isalnum()：判断是否是数字和字母 islower()：判断是否有字母，且字母为小写字母 isupper()：判断是否有字幕，且字母为大写字母 isspace()：判断是不是只有空格和换行符号 istitle()：判断字符串每个单词的首字母是否大写 isdecimal()：判断是不是数字 isnumeric()：判断是不是数字 isidentifier()：判断字符能否成为标识符 isprintable()：判断字符是否全部能打印的 isdigit、isdecimal、isnumeric三者的区别isdigit()True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字Error: 无 isdecimal()True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字Error: byte数字（单字节） isnumeric()True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节） 字符串分隔 split([sep[,maxsplit]])/rsplit([sep[,maxsplit]])：分别从左右按照sep字符串分隔，最多分隔maxsplit此，默认无数次 12345&gt;&gt;&gt; str=&apos;asd,fgh,jkl&apos;&gt;&gt;&gt; str.split(&apos;,&apos;)[&apos;asd&apos;, &apos;fgh&apos;, &apos;jkl&apos;]&gt;&gt;&gt; str.rsplit(&apos;,&apos;,1)[&apos;asd,fgh&apos;, &apos;jkl&apos;] splitlines()以\n或者\r或者\n\r分隔 123&gt;&gt;&gt; str='asd\nfgh\njkl'&gt;&gt;&gt; str.splitlines()['asd', 'fgh', 'jkl'] partition(sep)：将分隔符也作为一个元素列出来 12&gt;&gt;&gt; 'http://www.baidu.com'.partition('://')('http', '://', 'www.baidu.com') 字符串其他方法 join()：以特定的分隔符将字符串分隔123&gt;&gt;&gt; str='asdfg'&gt;&gt;&gt; '-'.join(str)'a-s-d-f-g' 字符串格式化输出python字符串格式化输出的三种方式 使用字符串格式格式化操作符——百分号% 使用字符串方法 format 使用 f-strings进行字符串格式化使用%进行格式化这种格式化表达式类似于C语言 格式化操作符（%） 说明 s 获取传入对象的str方法的返回值，并将其格式化到指定位置 r 与s一样，但输出方式是repr方式，而不是str c 整数：将数字转换成其unicode对应的值，10进制范围为 0&lt;=i&lt;=1114111（py27则只支持0-255）；字符：将字符添加到指定位置 d 有符号十进制（整数），将整数、浮点数转换成十 进制表示，并将其格式化到指定位置 i 有符号整数 u 无符号整数 o 将整数转换成八 进制表示，并将其格式化到指定位置 x 将整数转换成十六进制表示，并将其格式化到指定位置 X 与x一样，A-F是大写 e 浮点指数，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e） E 与e一样，E为大写 f 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位） F 浮点数十进制 g 浮点e或f，自动调整将整数、浮点数转换成 浮点型或科学计数法表示 G 浮点E或F，自动调整将整数、浮点数转换成 浮点型或科学计数法表示 % 当字符串中存在格式化标志时，需要用 %%表示一个百分号 注：Python中百分号格式化是不存在自动将整数转换成二进制表示的方式 举例123456789101112&gt;&gt;&gt; "%s|%r|%c" %("this is str","this is repr","C")"this is str|'this is repr'|C"&gt;&gt;&gt; "%d|%i|%o|%x|%X|" %(3,5,12,13,14)'3|5|14|d|E|'&gt;&gt;&gt; "%e|%E|%f|%F|%g|%G" %(1.5E3,1.5e3,13.5,13.5,1.5e13,13.5E15)'1.500000e+03|1.500000E+03|13.500000|13.500000|1.5e+13|1.35E+16'&gt;&gt;&gt; "%(string)-10s"%(&#123;'string':'1'&#125;)'1 &gt;&gt;&gt; "%(float)+10.2F"%(&#123;'float':3.1&#125;)' +3.10'&gt;&gt;&gt; "%(float)-10.2f"%(&#123;'float':3.1&#125;)'3.10 ' 使用format方法语法：{}.format(value)参数:（value):可以是整数，浮点数，字符串，字符甚至变量。Returntype：返回一个格式化字符串，其值在占位符位置作为参数传递。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#位置参数&gt;&gt;&gt; username='wanger'&gt;&gt;&gt; password=123456&gt;&gt;&gt; print ("&#123;&#125;'s password is &#123;&#125;".format(username,password))wanger's password is 123456 &gt;&gt;&gt; username='wanger'&gt;&gt;&gt; password=123456&gt;&gt;&gt; print ("&#123;1&#125;'s password is &#123;0&#125;".format(password,username))wanger's password is 123456 #下标参数&gt;&gt;&gt; si=['KB','MB','GB','TB','PB','EB','ZB','YB']&gt;&gt;&gt; '1000&#123;0[0]&#125;=1&#123;0[1]&#125;'.format(si)'1000KB=1MB'#浮点数精度&gt;&gt;&gt; '&#123;:.4f&#125;'.format(3.1415926)'3.1416'&gt;&gt;&gt; '&#123;:&gt;10.4f&#125;'.format(3.1415926)' 3.1416'&gt;&gt;&gt; 'this is a test &#123;t[0]&#125;'.format(t='hello')'this is a test h'&gt;&gt;&gt; 'this is a test &#123;t[1]&#125;'.format(t='hello')'this is a test e'#使用模块作为参数&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.platform'win32'&gt;&gt;&gt; "&#123;0.platform&#125;".format(sys)'win32'&gt;&gt;&gt; 'my laptop platform is &#123;s&#125;'.format(s=sys.platform)'my laptop platform is win32'&gt;&gt;&gt; 'my laptop platform is (s.platform)'.format(s=sys)'my laptop platform is (s.platform)'#关键字参数&gt;&gt;&gt; 'my name is &#123;name&#125; ,age is &#123;age&#125;'.format(name='wanger',age='25')'my name is wanger ,age is 25``` 当占位符&#123;&#125;为空时，Python将按顺序替换通过str.format（）传递的值。 str.format（）方法中存在的值本质上是元组数据类型，元组中包含的每个单独值都可以通过索引号调用，索引号以索引号0开头。 第三段代码的变量si是一个列表，&#123;0&#125;就代表format()方法的第一个参数，那么&#123;0[0]&#125;就代表列表的第一个元素，&#123;0[1]&#125;就代表列表的第二个元素 这个例子说明格式说明符可以通过利用（类似） Python 的语法访问到对象的元素或属性。这就叫做复合字段名 (compound field names) 。 以下复合字段名都是“ 有效的 ” 。 • 使用列表作为参数，并且通过下标索引来访问其元素（跟上一例类似） • 使用字典作为参数，并且通过键来访问其值 • 使用模块作为参数，并且通过名字来访问其变量及函数 • 使用类的实例作为参数，并且通过名字来访问其方法和属性 • 以上方法的任意组合 ###### format_spec参数表达式：format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]- fill ::= &lt;'any character'&gt;- align ::= "&lt;"'左对齐' | "&gt;"‘右对齐’ | "="‘在数字里，符号左对齐，数字右对齐 | "^"‘居中’- sign ::= "+" | "-" | " "（当sign=’+‘时，即使是正数也会显示符号，-只有为负数的时候才显示负号，为空格时，会在正数前面留下符号位）- width ::= integer (定义输出的宽度)fill和align以及后面的width相当于str方法中的center，ljust,rjust ```python&gt;&gt;&gt; '&#123;:+^15&#125;'.format('start')'+++++start+++++'&gt;&gt;&gt; '&#123;:+^15&#125;'.format('end')'++++++end++++++'&gt;&gt;&gt; '&#123;:*&lt;15&#125;'.format('end')'end************'&gt;&gt;&gt; '&#123;:*&gt;15&#125;'.format('start')'**********start'&gt;&gt;&gt; '&#123;:=+20&#125;'.format(10)'+ 10'&gt;&gt;&gt; print("&#123;:=10&#125;\n&#123;:=+20&#125;\n&#123;:-^10&#125;\n&#123;:=-13&#125;".format(10,10,'-',-15)) 10+ 10----------- 15 #只有在数字显示里，显示二进制数，八进制数，十六进制数的时候，需要显示前面的0b,0o,0x的时候才会用到 123456&gt;&gt;&gt; "&#123;0:8b&#125;,&#123;0:8o&#125;,&#123;0:8x&#125;".format(10)' 1010, 12, a'&gt;&gt;&gt; "&#123;0:b&#125;,&#123;0:o&#125;,&#123;0:x&#125;".format(10)'1010,12,a'&gt;&gt;&gt; ("&#123;0:#8b&#125;,&#123;0:#8o&#125;,&#123;0:#8x&#125;".format(10))' 0b1010, 0o12, 0xa' ,符号是表示数字时每三位中间加， 12&gt;&gt;&gt; '&#123;:,&#125;'.format(100000000000)'100,000,000,000' 0是固定宽度前面补0 .precision ::= integer(精度显示) 12&gt;&gt;&gt; &apos;&#123;:010.5&#125;&apos;.format(3.1415926)&apos;00003.1416&apos; type ::= “b” | “c” | “d” | “e” | “E” | “f” | “F” | “g” | “G” | “n” | “o” | “s” | “x” | “X” | “%” (跟之前使用%表示的相等)&ensp;&ensp;- 当为字符时：使用s，默认就是s&ensp;&ensp;- 当为整数时：b,o,x和X是二进制、八进制、十六进制，c是数字按Unicode转换成字符，d是正常十进制，默认就是d。也可以使用n来代替d 12&gt;&gt;&gt; "&#123;0:d&#125;,&#123;0:b&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;".format(10)'10,1010,12,a,A' &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 为浮点数时：e和E是指数，f和F是浮点数。g和G是同一的，也可以使用n来代替g, %是显示百分比12&gt;&gt;&gt; "&#123;0:e&#125;,&#123;0:F&#125;,&#123;0:g&#125;,&#123;0:n&#125;,&#123;0:%&#125;".format(10.3)'1.030000e+01,10.300000,10.3,10.3,1030.000000%' 使用f-strings方法进行格式化f-strings也称为“格式化字符串文字”，f字符串是f在开头有一个字符串文字，其中以 {} 包含的表达式会进行值替换。表达式在运行时进行评估，然后使用format协议进行格式化。其中以 {} 包含的表达式会进行值替换。 特点 代码简洁，没有多余的引号 括号{}里面的变量，可以是字符串类型，也可以是整型、浮点型，或者是复杂类型，比如数组、词典等，会自动转换成成字符串形式。 括号{}里面还可以是函数，比如 f’数组a的长度为:{len(a)}’。一句话，只要是位于 {} 中的，都会当做 python 代码来执行。但里面只能写表达式，不能写执行语句如{a=2}之类的。 f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式，速度非常快 简单举例1234567&gt;&gt;&gt; name=&apos;wanger&apos;&gt;&gt;&gt; age=25&gt;&gt;&gt; f&quot;hello,I&apos;m &#123;name&#125;,my age &#123;age&#125; &quot;&quot;hello,I&apos;m wanger,my age 25 &quot;#也可以使用大写F&gt;&gt;&gt; F&quot;hello, I&apos;m &#123;name&#125;,my age &#123;age&#125; &quot;&quot;hello, I&apos;m wanger,my age 25 &quot; 当然也可以进行简单的计算12&gt;&gt;&gt; f&quot;&#123;2*3&#125;&quot;&apos;6&apos; 也可以调用函数123456&gt;&gt;&gt; def test(input):... return input.lower()...&gt;&gt;&gt; name=&apos;WangEr&apos;&gt;&gt;&gt; f&quot;&#123;test(name)&#125; is funny&quot;&apos;wanger is funny&apos; 还可以选择直接调用方法123&gt;&gt;&gt; name='WangEr'&gt;&gt;&gt; f"&#123;name.lower()&#125; is funny"'wanger is funny' 在使用字典的时候。如果要为字典的键使用单引号，请记住确保对包含键的f字符串使用双引号。123comedian = &#123;&apos;name&apos;: &apos;wanger&apos;, &apos;age&apos;: 25&#125;f&quot;The comedian is &#123;comedian[&apos;name&apos;]&#125;, aged &#123;comedian[&apos;age&apos;]&#125;.&quot;&apos;The comedian is wanger, aged 25.&apos; 使用字符串的场景 使用多个界定符分隔字符串split只能使用单一字符串，如果要使用多个分隔符的话，就要用到正则表达式模块了1234&gt;&gt;&gt; str=&apos;asd,dfg;zxc ert uio&apos;&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r&apos;[;,\s]\s*&apos;,str)[&apos;asd&apos;, &apos;dfg&apos;, &apos;zxc&apos;, &apos;ert&apos;, &apos;uio&apos;] []表示里面字符任意匹配。[;, ]表示；或者，或者空格，\s*表示任意个前面字符 字符串开头或结尾匹配比如要看一个地址是否是http://或者ftp://开头或者查看文件后缀是不是TXT格式可以这样查看 1234567891011&gt;&gt;&gt; url='http://www.baidu.com'&gt;&gt;&gt; ftp='ftp://www.baidu.com'&gt;&gt;&gt; url.startswith(('http://','ftp://'))True&gt;&gt;&gt; txt='ziyuan.txt'&gt;&gt;&gt; txt.endswith('txt')True&gt;&gt;&gt; url[0:7]=="http://" or url[0:6]=="ftp://"True&gt;&gt;&gt; txt[7:10]=="txt"True 用shell通配符我们还可以使用shell通配符来检查文件的结尾，这需要用到fnmatch模块fnmatch不区分大小写，fnmatchcase是区分大小写的 123456789&gt;&gt;&gt; from fnmatch import fnmatch,fnmatchcase&gt;&gt;&gt; fnmatch('log.txt','*.txt')True&gt;&gt;&gt; fnmatch('log.TXT','*.txt')True&gt;&gt;&gt; fnmatchcase('log.TXT','*.txt')False&gt;&gt;&gt; fnmatchcase('log.TXT','*.TXT')True 匹配和搜索特定格式的文本普通匹配可以使用find方法，如果是特定格式的话还是会用到正则模块 1234567891011121314&gt;&gt;&gt; date1='2018/10/24'&gt;&gt;&gt; date2='2018/12/21'&gt;&gt;&gt; date3='2018-12-05'&gt;&gt;&gt; def isdate(date):... if re.match(r'\d+/\d+/\d+',date):... print ('match OK')... else:... print ('not match')&gt;&gt;&gt; isdate(date1)match OK&gt;&gt;&gt; isdate(date2)match OK&gt;&gt;&gt; isdate(date3)not match 在正则模块re中\d表示单个数字，+表示一个或多个前面的字段 搜索和替换特定的文本格式普通的匹配可以使用replace方法，如果匹配特定格式，还是要用正则模块re12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; date='today is 13/12/2018'&gt;&gt;&gt; re.sub(r'(\d+)/(\d+)/(\d+)',r'\3-\2-\1',date)'today is 2018-12-13'&gt;&gt;&gt; datepat=re.compile(r'(\d+)/(\d+)/(\d+)') #为了防止每次都要定义匹配模式，可以在这里定义一个匹配的变量，以后匹配直接调用这个变量&gt;&gt;&gt; datepat.sub(r'\3-\2-\1',date)'today is 2018-12-13'&gt;&gt;&gt; date='yestory is 12/12/2018,today is 13/12/2018'&gt;&gt;&gt; datepat.subn(r'\3-\2-\1',date)('yestory is 2018-12-12,today is 2018-12-13', 2) \1,\2,\3分别代表前面匹配模式中的第一个括号匹配到的，第二个括号匹配到的，第三个括号匹配到的，使用subn方法可以看到匹配到几次 忽略大小写的搜索替换如果要忽略大小写还是要用到re模块，需要用到的是re的IGNORECASE方法12345678&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('replace','Replace,replace,REPLACE')['replace']&gt;&gt;&gt; re.findall('replace','Replace,replace,REPLACE',flags=re.IGNORECASE)['Replace', 'replace', 'REPLACE']&gt;&gt;&gt; str='Replace is the same as REPLACE'&gt;&gt;&gt; re.sub('replace','WORD',str,flags=re.IGNORECASE)'WORD is the same as WORD' 最短匹配模式用正则表达式匹配某个文本模式，而他找到的是最长匹配，如果要匹配最短字符，可以用下面的方法 12345678910&gt;&gt;&gt; strpat=re.compile(r&apos;\&quot;(.*)\&quot;&apos;)&gt;&gt;&gt; text=&apos;this is my &quot;name&quot;&apos;&gt;&gt;&gt; strpat.findall(text)[&apos;name&apos;]&gt;&gt;&gt; text=&apos;this is my &quot;name&quot; and this is my &quot;age&quot;&apos;&gt;&gt;&gt; strpat.findall(text)[&apos;name&quot; and this is my &quot;age&apos;]&gt;&gt;&gt; strpat=re.compile(r&apos;\&quot;(.*?)&quot;&apos;)&gt;&gt;&gt; strpat.findall(text)[&apos;name&apos;, &apos;age&apos;] 删除字符串中不需要的字符去掉字符串开头，中间或者结尾不想要的字符串，比如空白 12345678910&gt;&gt;&gt; s='hello world \n'&gt;&gt;&gt; s.strip()'hello world'&gt;&gt;&gt; s.lstrip()'hello world \n'&gt;&gt;&gt; s.rstrip()'hello world'&gt;&gt;&gt; import re&gt;&gt;&gt; re.sub(r'\s+','',s)'helloworld' 合并拼接字符串 12345678910&gt;&gt;&gt; a=&apos;hello&apos;&gt;&gt;&gt; b=&apos;world&apos;&gt;&gt;&gt; a+&apos; &apos;+b&apos;hello world&apos;&gt;&gt;&gt; &apos;&#123;&#125; &#123;&#125;&apos;.format(a,b)&apos;hello world&apos;&gt;&gt;&gt; &apos; &apos;.join([a,b])&apos;hello world&apos;&gt;&gt;&gt; a=print(a,b)hello world]]></content>
      <tags>
        <tag>python数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-os模块学习笔记]]></title>
    <url>%2F2018%2F11%2F30%2Fpython-os%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[import osos.mkdir(name) #创建目录os.path.exists(name) #判断文件或者目录是否存在os.path.isdir(name) #判断指定对象是否为目录。是True,否则False。os.mknod(name) #创建一个文件os.path.isfile(name) #判断文件是否存在，存在返回True，否则返回False12345678&gt;&gt;&gt; os.mkdir('aaaa')&gt;&gt;&gt; os.path.exists('aaaa')True&gt;&gt;&gt; os.path.isdir('aaaa')True&gt;&gt;&gt; os.mknod('test.txt')&gt;&gt;&gt; os.path.isfile('test.txt')True os.rmdir(name) #删除一个目录os.remove(name) #删除一个文件123456&gt;&gt;&gt; os.rmdir('aaaa')&gt;&gt;&gt; os.path.isdir('aaaa')False&gt;&gt;&gt; os.remove('test.txt')&gt;&gt;&gt; os.path.isfile('test.txt')False os.getcwd() #获取当前路径，相当于Linux下的pwd命令os.path.abspath(file|dir) #获取文件或者目录的绝对路径os.path.basename(name) #获取文件名或文件夹名os.path.dirname(name) #获取文件或文件夹的路径12345678&gt;&gt;&gt; os.getcwd()'/root/SuXinProject'&gt;&gt;&gt; os.path.abspath('.')'/root/SuXinProject'&gt;&gt;&gt; os.path.dirname('/root/user.sh')'/root'&gt;&gt;&gt; os.path.basename('/root/user.sh')'user.sh' os.path.splitext #分离文件名与扩展名os.path.split #分离目录与文件名os.path.join(path,name) #连接目录与文件名或目录123456&gt;&gt;&gt; os.path.split('/root/user.sh')('/root', 'user.sh')&gt;&gt;&gt; os.path.splitext('/root/user.sh')('/root/user', '.sh')&gt;&gt;&gt; os.path.join('/root/','user.sh')'/root/user.sh' os.chdir(dir) #切换目录os.listdir(dir) #列出目录下的所有目录和文件os.path.getsize(file|dir) #获取文件的大小，如果是目录则直接返回0os.stat(name) #获取文件属性os.system(commond) #执行系统命令os.rename(old,new) #文件重命名1234567891011&gt;&gt;&gt; os.chdir('/root')&gt;&gt;&gt; os.listdir('.')['.vnc', 'mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz', '.pydistutils.cfg', '.cache', '.git', 'file', '.mozilla', '.rnd', 'GUESS', 'Music', 'run.sh', '.finalshell', '.viminfy.tmp', '.config', 'docker-logspout-elk', 'Desktop', 'sed.txt', '100oush.sh', 'pid2.txt', '.cshrc', 'mynginx', '.bash_profile', 'etcd', 'sh.txt', 'oushu.sh', '.docker', '.viminfx.tmp', 'pid.sh', 'test', '.pycharm_helpers', 'user.sh', 'net', 'jiujiu.sh', '.dbus', 'sum100.sh', '.ssh', '.bashrc', 'LinEnum', 'sysinfo.sh', '.esd_auth', 'for100oushu.sh', 'pid1.txt', '.local', 'SuXinProject', 'phone.sh', '.ansible', '.viminfz.tmp', 'Documents', '.viminfo.tmp', 'study', '.ICEauthority', 'Pictures', 'for99.sh', '.bash_logout', '.pid.sh.swp', 'qiuhe.sh', 'pid.txt', '.viminfo', '.npm', 'fors00oushu.sh', '.pki', '99.sh', '.gitconfig', 'etcd-v3.2.10-linux-amd64', 'nohup.out', 'Public', 'user1.sh', 'diff.txt', '.Xauthority', '.virtualenvs', '.node_repl_history', '.pip', '.bash_history', 'Downloads', 'Videos', 'killpid.sh', 'Templates', 'daemon.json', 'beijing', 'dif', '.tcshrc', 'kill.sh', '.mysql_history', 'biao.txt', 'blog']&gt;&gt;&gt; os.path.getsize('./user.sh')299&gt;&gt;&gt; os.stat('./user.sh')posix.stat_result(st_mode=33261, st_ino=143152, st_dev=64769L, st_nlink=1, st_uid=0, st_gid=0, st_size=299, st_atime=1543135673, st_mtime=1542818209, st_ctime=1542818209)&gt;&gt;&gt; os.system('whoami')root0&gt;&gt;&gt; os.rename('99.sh','999.sh') os.getuid() #获取用户idos.getgid() #获取用户组idos.environ[‘环境变量名称’]=’环境变量值’ #设置环境变量os.environ[‘环境变量名称’] #获取环境变量os.getenv(‘环境变量名称’) #获取环境变量123456789&gt;&gt;&gt; os.getuid()0&gt;&gt;&gt; os.getgid()0&gt;&gt;&gt; os.environ['PYTHON']='/usr/local/bin'&gt;&gt;&gt; os.environ['PYTHON']'/usr/local/bin'&gt;&gt;&gt; os.getenv('PYTHON')'/usr/local/bin' os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) # 从上到下或从下到上遍历树来生成目录树中的文件名 参数 top - 以目录为根的每个目录产生3元组，即（dirpath，dirnames，filenames）。dirpath为目录的路径，为一个字符串。dirnames列出了目录路径下面所有存在的目录的名称。filenames列出了目录路径下面所有文件的名称。不明白的可以看下图 topdown - 如果可选参数topdown为True或未指定，则从上到下扫描目录。如果topdown设置为False，则会自下而上扫描目录，不懂的话可以看下面的代码就明白了 onerror - 这可能会显示错误以继续行走，或者引发异常以中止行走。 followlinks - 如果设置为true，则访问符号链接指向的目录。123456789101112131415161718192021222324252627&gt;&gt;&gt; for root, dirs, files in os.walk("."):... for name in dirs:... print(os.path.join(root,name))... ./shell编程./test./ftp./hexo&gt;&gt;&gt; for root, dirs, files in os.walk(".", topdown=False):... for name in files:... print(os.path.join(root, name))... ./shell编程/index.html./test/index.html./ftp/index.html./hexo/index.html./index.html&gt;&gt;&gt; for root, dirs, files in os.walk("."):... for name in files:... print(os.path.join(root, name))... ./index.html./shell编程/index.html./test/index.html./ftp/index.html./hexo/index.html]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http学习笔记]]></title>
    <url>%2F2018%2F10%2F29%2Fhttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[http:hypertext transfer protocol：超文本传输协议超文本：带有超级链接的链接超级链接：能够实现在不同的文档中跳转http/0.9版本：只支持纯文本的传输（带有超级连接）ASCII码&emsp;&emsp;HTML:hypertext mark&emsp;&emsp;language:超文本标记语言&emsp;&emsp;支持get方法，且不支持请求头 Browser:浏览器URI:uniform resourceindentifier:统一资源标识符URL：uniform resource locator：统一资源定位符&emsp;&emsp;统一：路径格式的统一&emsp;&emsp;protocal://address/to/resouce_pathweb资源：用URL标识，并且让用户客户端代理（浏览器）能够访问的文件HTML：把多种web资源整合成一个HTML文档，并能够让浏览器访问显示的一种语言http/1.0版本：&emsp;&emsp; 1.引入MIME机制（为了实现能够传输分文本信息）&emsp;&emsp; MIME:multi Internet mail extension：多用途互联网邮件交换协议，将非文本数据在传输之前重新编码为文本格式，接收方能够利用相反的方式将其重新还原为原来的格式，还能调用相应的应程序显示此文件&emsp;&emsp;扩展：SMTP:simple mail transfer protocol：简单邮件传输协议 &emsp;&emsp;2.请求与响应头域 &emsp;&emsp;3.响应对象以一个响应状态行开始 &emsp;&emsp;4.响应对象不止限于文本 &emsp;&emsp;5.开始支持客户端通过POST方法向web服务器提交数据，支持GET、HEAD、POST方法 &emsp;&emsp;6.支持长连接（但默认还是使用短连接）， &emsp;&emsp;7.缓存机制（加快速度），以及身份验证 动态网页：web服务器存储的文档是非HTML文档，而是动态语言，动态语言生成的脚本能够接受用户的参数后形成HTML文档，把生成的文档返回给客户端 http/1.1是目前使用最广泛的协议版本，在http1.0中使用长连接需要添加请求头Connection:Keep-Alive,而在http1.1默认支持长连接，除非特殊声明不支持（HTTP请求首部加上Connection:Close）,http1.1引入了许多关键优化：keepalive连接。chunked编码传输，字节范围请求，请求流水线等HTTP1.1协议中共定义了八种方法来表明Request-URI指定的资源的不同的操作方式：&emsp;&emsp;1. OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web发送’*’的请求来测试服务器的功能性&emsp;&emsp;2. HEAD：向服务器索要与GET请求相一致的响应，只不过想硬体将不会被返回，这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息&emsp;&emsp;3. GET：向特定的资源发出请求。注意：GET方法不应被用于产生“副作用”的操作中，例如在web app中，其中一个原因是GET可能会被网络爬虫等随意访问&emsp;&emsp;4. POST：向指定资源提交数据进行数据请求（例如提交表单或者上传文件）.数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改&emsp;&emsp;5. PUT：向指定资源位置上传其最新内容&emsp;&emsp;6. DELETE：请求服务器删除Request-URI所标识的资源&emsp;&emsp;7. TRACE：回显服务器收到的请求，主要用于测试和诊断&emsp;&emsp;8. CONNECT：http/1.1协议中预留给能够将连接改为管道方式的代理服务器 http/2.0是下一代http协议，目前应用还非常少，主要特点有： &emsp;&emsp;多路复用（二进制分帧）：在二进制分帧层上，http2.0将所有传输的信息分割为更小的消息和帧，并对他们采用二进制格式的编码 &emsp;&emsp;头部压缩：当一个客户端向相同服务器请求许多资源时，向来自同一个网页的图像，将会有大量的请求看上去几乎同样的，这就需要压缩技术对付这种几乎相同的信息 &emsp;&emsp;随时复位：http1.1一个缺点是当http信息有一定长度大小数据传输时，你不能方便地随时停止他，中断TCP连接的代价是昂贵的，使用http2的RST_STREAM将能够方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率 服务器端推流：server Push:客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用. 优先权和依赖：每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另一个流，优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突出抓住重点流 http报文：请求报文（http request）和响应报文（http response） &emsp;&emsp;请求报文语法：123&lt;method&gt;&lt;request-URI&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; &emsp;&emsp;响应报文语法：123 &lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headrers&gt;&lt;entity-body&gt; 响应报文的状态代码：&emsp;&emsp;1xx：纯信息，已经弃用&emsp;&emsp;200：“成功“类的信息&emsp;&emsp;301：永久重定向&emsp;&emsp;302：临时重定向&emsp;&emsp;304：浏览器缓存&emsp;&emsp;403：请求不到首页，权限被拒绝&emsp;&emsp;404：资源找不到&emsp;&emsp;500：服务器内部错误，程序代码错误&emsp;&emsp;502：找不到后端的错误&emsp;&emsp;504：请求超时 Web服务器处理并发连接请求的并发模型&emsp;&emsp;1.单线程web服多器(Single-threaded web servers):此种架构方式中,web服多器一次处理一个请求.结束后读取井处理下一个请求.在某请求处理辻程中,其它所有的清求将被阻塞,因此;在并发请求较多的场景中将会出现严重的性能问题（即一次只能处理一个请求） &emsp;&emsp;2.多进程/多线程web服灸器:此种架构方式中, web服多器生成多个进程或线程并行处理多个用戸请求,进程或线程可以按需或事先生成、有的web服务器应用程序为每个用戸请求生成一个単独的进程或线程来进行响应,不过, 一旦并发请求数量达到成千上万吋,多个同吋进行的进程或线程将会消耗大量的系統资源（即每个进程只能响应一个请求，并且一个进程对应一个线程） &emsp;&emsp;3.I/O多路复用web服努器:为了能够支持更多的并友用户清求,越来越多的web服努器正在采用多种复用的架构–即同歩监控所有的连接靖求的活动状态，当一个连接的状态发生改变时(如数据准各完毕或发生某错误)将为其执行一系列特定操作；在操作完成后此连接将重新变回暂时的稳定态并返回至打开的连接列表中，直到下次的状态改变，由于其多路复用的特性,进程或线程不会被空闲的连接所占用，因而可以提供高效的工作模弌.（这种架构可以理解为一个进程可以生成多个线程，每个请求交给一个线程程迸行处理)]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全学习网址]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[网络安全学习网址 http://www.sec-wiki.com/skill/安全技能(里面渗透逆向编程都有介绍)http://blog.knownsec.com/Knownsec_RD_Checklist/ 知道创宇研发技能表v3.0https://www.shentoushi.top/network 渗透师 （网络安全学习网址导航）https://www.anquanquan.info/ 安全圈info（网络安全学习导航网址） 综合学习平台： https://secquan.org 圈子社区https://github.com/cxf210/Scanners-Boxhttp://edu.gooann.com/ 谷安网校https://edu.aqniu.com/ 安全牛课堂http://www.jikexueyuan.com/ 极客学院http://www.hetianlab.com/ 合天http://www.moonsos.com/ 米安网http://www.ichunqiu.com/ i春秋http://www.honyaedu.com/ 红亚http://www.baimaoxueyuan.com/ 白帽学院http://www.simplexue.com/ctf/index 西普学院http://www.imooc.com/course/list 慕课http://www.secbox.cn/ 安全盒子http://www.freebuf.com/ freebufhttp://bobao.360.cn/ 360安全播报https://github.com/cxf210/Scanners-Box github上的资源库https://github.com/cxf210/dockerhttps://github.com/cxf210/fuzzdbhttps://github.com/cxf210/webshellgithub上的webshellhttp://drops.wooyun.org/ 乌云知识库http://wiki.wooyun.org/ WooYun WiKihttps://www.91ri.org/ 91rihttps://www.t00ls.NET/tools 土司https://bbs.77169.com/forum.php 华盟网http://www.ijiandao.com/ 爱尖刀http://www.secist.com/ 即刻安全http://www.secwk.com/article/index.html 威客众测http://bluereader.org/ 深蓝阅读http://www.shentou.org/ 黑客安全军火库http://netsecurity.51cto.com/ 51ctohttp://security.csdn.net/ csdnhttp://www.80sec.com/ 80sec teamhttps://security.alibaba.com/blog.htm?spm=0.0.0.0.knOqaI 阿里巴巴安全响应中心http://security.tencent.com/index.PHP/blog 腾讯安全应急响应中心博客http://security.360.cn/blog 360安全应急响应中心博客http://sec.baidu.com/index.php?research/list 百度安全应急响应中心博客 博客推荐 http://security.tencent.com/index.php/blog &gt; http://217.logdown.com/ 217https://laolisafe.com/ 大老李的博客http://mannix.top/ mannix的博客http://www.raosong.cc/ 折戟博客http://www.blue-lotus.net blue-lotus 蓝莲花http://blog.0ops.net/ 0opshttp://blog.amanhardikar.com/#homehttp://le4f.net/ e4fhttp://www.programlife.net/ 代码疯子http://www.hackdog.me/ redrain’bloghttp://www.syjzwjj.com/ 俊杰http://syclover.sinaapp.com/ 三叶草安全小组http://appleu0.sinaapp.com/ appleU0大大http://bl4ck.in/ tomato表哥http://www.sco4x0.com/ 4叔叔http://laterain.sinaapp.com/ 白神http://0nly3nd.sinaapp.com/ 0nly3ndhttp://hijacks.in/ LateRain’bloghttp://www.waitalone.cn/ 独自等待http://evilcos.me/ 余弦http://www.moonsec.com/ 暗月http://www.cnblogs.com/xuanhun/ 玄魂https://www.leavesongs.com/ 离别歌http://huaidan.org/ 鬼仔http://www.03sec.com/ sky的自留地http://joychou.org/ jc老师http://www.unhonker.com/ 90’s bloghttp://www1.taosay.net/ 道哥的黑板报http://blog.knownsec.com/ 知道创宇http://www.sadk.org/ 焠安http://www.cnseay.com/ seay’bloghttp://blog.aptsec.net/ AptSec Teamhttp://lcx.cc/ 网络安全研究中心http://www.kali.org.cn/ kali中文网http://xiao106347.blog.163.com/ xiao106347 kali折腾 渗透: http://www.wooyun.org/ 乌云http://bbs.blackbap.org/ 习科http://www.1937cn.net/ 1937http://forum.cnsec.org/ 暗组http://www.k33nteam.org/ keen teamhttp://forum.eviloctal.com/ 邪恶八进制http://www.evil0x.com/ 邪恶十六进制http://www.myhack58.com/ 黑吧安全吧http://www.cnhonkerarmy.com/ 中国红客红盟http://www.chinahacker.com/ 中国黑客联盟http://www.hxhack.com/ 华夏黑客联盟http://www.heikexiehui.com/ 中国黑客协会官网http://www.hackbase.com/ 黑基http://www.2cto.com/ 红黑联盟http://bbs.2cto.com/ 红黑联盟论坛http://www.hackwd.com/http://www.heishou.com.cn/ 黑手安全网https://www.sitedirsec.com/ 非安全中国网http://www.zatokasztuki.com/ 学生技术联盟 逆向： http://www.52pojie.cn/ 吾爱破解http://bbs.pediy.com/ 看雪论坛https://www.chinapyg.com/ 飘云阁论坛https://0x00sec.org/ 国外逆向论坛https://github.com/onethawt/reverseengineering-reading-list/blob/master/README.md 逆向工程阅读清单https://github.com/RPISEC/Malware/blob/master/README.md 恶意软件分析 编程： http://www.he11oworld.com/ hello wordhttp://www.w3school.com.cn/ w3schoolhttp://www.runoob.com/ 菜鸟http://www.51zxw.net/https://github.com/http://navisec-Git.qiniudn.com/http://c.biancheng.net/cpp/http://www.liaoxuefeng.com/http://www.php100.com/https://ruby-china.org/wikihttp://bbs.csdn.net/forums/Java/http://outofmemory.cn/tutorial/ 书籍： http://zhuanlan.zhihu.com/Evi1m0/19706178 Evi1m0: 书籍推荐http://www.douban.com/doulist/3339701/ 信息安全必读书单http://www.douban.com/doulist/1363865/ 信息安全经典书籍http://www.zhihu.com/question/21390646http://my.oschina.net/bluefly/blog/335409?utm_source=tuicool&amp;utm_medium=referralWeb安全核心书单连载《安全参考》http://www.douban.com/group/topic/72383272/(2013年第一期--2015年第一期)全集《书安》(更新中)http://www.secbox.cn/hacker/8205.html 书安SecBook第一期《icloud iOS安全大揭秘》http://www.secbox.cn/hacker/7366.html 书安SecBook第二期《信息安全攻防赛》渗透实战文章可以看看里的杨凡(http://blog.sina.com.cn/s/articlelist_1758675673_4_1.html)和法克文章（http://pan.baidu.com/share/link?shareid=249629&amp;uk=2198816663） 工具： 链接：https://pan.baidu.com/s/1tt9O4etSxkFzPsRCamOInA提取码：dt8o 个人收集的一些ctf工具包https://github.com/zardus/ctf-tools github上的ctf工具http://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=388015 吾爱破解工具包http://down.52pojie.cn/ 爱盘 – 在线破解工具包，教程http://www.52pojie.cn/thread-341238-1-1.html 吾爱破解论坛专用破解虚拟机ctf常用工具包请看http://tieba.baidu.com/p/3933947157里面群文件 其他 http://www.zhihu.com/topic/19558642 黑客知乎话题http://www.zhihu.com/topic/20011446 ctf知乎话题http://www.zhihu.com/topic/19561983 信息安全知乎话题http://zhuanlan.zhihu.com/evilcos/19961466 余弦知乎专栏 CTF方面 http://blog.idf.cn/2015/02/ctf-field-guidehttp://tieba.baidu.com/p/3933947157 ctf大全https://ctftime.org/event/list/upcoming 各种CTF赛事预告(ps:国内各个高校或企业举办的比赛请进http://tieba.baidu.com/p/3933947157里面的群) 平时ctf练习ctf逆向: https://ctf.pediy.com/ 看雪ctfhttp://reversing.kr/http://pwnable.kr/http://exploit-exercises.com/http://overthewire.orghttp://security.cs.rpi.edu/courses/binexp-spring2015/ bin 干货区http://www.52pojie.cn/forum-67-1.html 『2014CrackMe大赛』 SQL: https://github.com/Audi-1/sqli-labshttp://redtiger.labs.overthewire.org/ ctf XSS: http://prompt.ml/http://xss.pkav.net/xss/http://www.doscn.org/xss/http://xss-quiz.int21h.jp/http://escape.alf.nu/https://xss-game.appspot.com/ 谷歌的xss游戏 密码学：http://cryptopals.com/ ctf综合练习：http://ctf.nuptsast.com/login 南邮大学ctfhttp://hackinglab.cn/ 网络信息安全攻防学习平台https://www.91ctf.com/session 安恒竞赛平台http://ctf.bugku.com/new bugkuctf练习平台http://captf.com/ ctf题目http://cafebabe.cc/nazo/ 脑洞开发，与ctf只有那么一点关系，有85关了http://1111.segmentfault.com/ 光棍节程序员闯关秀http://www.helloisa.com/test/http://www.fj543.com/hack/ 黑客丛林之旅http://monyer.com/game/game1/ 梦之光芒的小游戏http://oj.xctf.org.cn/ XCTF_OJ练习平台http://hackgame.blackbap.org/ 习科黑客游戏http://ctf.3sec.cn/ Jlu.CTFhttp://www.baimaoxueyuan.com/ctf 白帽学院ctf挑战赛http://www.ichunqiu.com/tiaozhans i春秋ctf挑战http://ctf.idf.cn/ idf 实验室http://www.dvwa.co.uk/ DVWAhttp://ctf.moonsos.com/pentest/index.php 米安网ctfhttp://www.hetianlab.com/CTFrace.html 合天ctfhttp://www.shiyanbar.com/ctf/index 实验吧(前名西普学院）http://hkyx.myhack58.com/ 黑吧安全网-红客闯关游戏http://202.108.211.5/ 实训竞赛系统 国外比较好的几个综合练习平台 https://ctf365.com/https://hack.me/s/https://ringzer0ctf.com/challengeshttps://www.hackergateway.com/http://challengeland.co/http://www.hackertest.net/http://www.wechall.nethttps://www.vulnhub.com/http://insight-labs.org/http://wargame.kr/https://ctflearn.com/http://canyouhack.it/https://pentest.training/index.phphttp://hackit.sinaapp.com/http://webhacking.kr/http://fun.coolshell.cn/http://ringzer0team.com/challengehttps://backdoor.sdslabs.co/https://www.enigmagroup.org/pages/challengeshttp://overthewire.org/wargames/natas/natas2.htmlhttp://smashthestack.org/ 漏洞利用练习网站 ctf writeup(WP): 直接百度:writeup(一边看一边总结，有道笔记，印象笔记什么的，最好能复现)http://drops.wooyun.org/?s=writeup&amp;submit=%E6%90%9C%E7%B4%A2http://bobao.360.cn/ctf/https://github.com/ctfs/ 各种 writeuphttp://sec.yka.me/ CTF Writeup Summaryhttps://ctf-team.vulnhub.com/ Write Upshttp://hebin.me/https://blog.csdn.net/gyt478922579/article/details/53204891?locationNum=11&amp;fps=1https://blog.csdn.net/xuqi7/article/details/51635360]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos系统7的ftp版本创建目录和匿名用户登录的测试]]></title>
    <url>%2F2018%2F09%2F13%2Fcentos%E7%B3%BB%E7%BB%9F7%E7%9A%84ftp%E7%89%88%E6%9C%AC%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E5%92%8C%E5%8C%BF%E5%90%8D%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[centos6系统使用的ftp是2.0以上的版本，而centos7使用的是3.0.2版本 首先说一下ftp使用匿名用户创建目录在centos7下只能在pub下创建文件夹，而且pub用户属主必须是ftp或者将pub目录授予777的权限，也就是说ftp用户在pub目录下必须具有写的权限。在这之前需要确保配置文件这几个选项为YES，这几个选项在配置文件里都是默认开启的，还有selinux要处于Permissive状态123anon_mkdir_write_enable=YESanon_upload_enable=YESanonymous_enable=YES 还有centos7下拒绝访问ftp服务的权限首先，ftp的访问跟ftp/pub的权限是没关系的，在正常情况下，授予ftp目录777的权限，是拒绝用户访问的如果将ftp目录的属主和属组都修改成ftp用户，将ftp目录的权限修改回755，也是不能访问的将配置文件的umask修改成000，并且重启服务，还是不能访问，但是如果我将ftp的目录的属主和属组都修改成ftp，而ftp的目录权限修改成557，那么ftp服务就可以正常访问了当我把ftp的属主和属组又修改成root之后，ftp服务又不能访问了我再把ftp的属主和属组都修改成ftp,,ftp服务还是可以正常的访问如果我再将ftp的目录权限修改成335，而属主和属组都是root，那么ftp也是可以访问的保持权限不变，而属主和属组改为ftp，那么ftp服务还是不能访问我再修改ftp目录的权限为445，将ftp目录的属主和属组都改为root，ftp服务还是可以访问的ftp目录的权限不变，修改ftp目录的属主和属组为ftp,ftp是可以进行访问的这里属主和属组都不改变，分别修改ftp目录的权限为665和225，结果ftp服务都不能访问也就是说不能给ftp用户写的权限，否则不能访问ftp。那如果我修改一下默认目录试试呢，我将ftp默认访问路径修改成/var/test，再次进行测试发现test目录的权限也是不能有写权限，否则不能访问因此，我们可以得出结论：访问ftp服务的匿名用户不能有写权限，这也就是为什么ftp目录下匿名用户不能创建子目录的原因]]></content>
      <categories>
        <category>ftp</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程之条件测试]]></title>
    <url>%2F2018%2F08%2F18%2Fshell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于条件测试命令可以使用man test命令查看 条件测试语句语法1.test 测试语句2.[ 测试语句 ]3.[[ 测试语句 ]]4.((测试语句))其中1和2除了语法不一样，功能基本是一样的，而第3种语法他可以使用通配符进行匹配，第四种语法除了用于整数的比较，更多的还是进行一些整数的运算，不过平时经常用到的还是第2、3种语法结构。 条件测试类型 文件测试 数值测试 字符串测试 逻辑测试文件测试格式：1.test 文件测试符 file2.[ 文件测试符 file ] #中括号的两边都需要有空格3.[[ 文件测试符 file ]] #中括号两边需要有空格常用文件测试操作符：123456789101112-b: 文件是否存在，并且为块文件-c：文件是否存在，并且为字符文件-d: 文件是否存在，并且为一个目录（在linux下,万物皆为文件）-e: 文件是否存在-f: 文件是否存在，并且为普通文件-s: 文件是否存在，并且文件大小大于零-L: 文件是否存在，并且为链接文件-r: 文件是否存在，并且文件可读-w: 文件是否存在，并且文件可写-x: 文件是否存在，并且文件可执行file1 -nt file2 文件1是否比文件2新(文件新旧是按照文件修改时间来区分的)file1 -ot file2 文件1是否比文件2旧 实例：1234567891011[root@docker ~]# touch wanger #新建一个普通文件[root@docker ~]# test -f wanger &amp;&amp; echo 0 || echo 10 #测试文件是否是普通文件，如果是输出0，否则输出1[root@docker ~]# [ -d wanger ] &amp;&amp; echo 0 || echo 11 #测试文件是否是一个目录，如果是输出0，否则输出1[root@docker ~]# touch wangerxiao 创建一个普通文件wangerxiao[root@docker ~]# test wanger -nt wangerxiao &amp;&amp; echo 0 || echo 11 #比较wanger是否比wangerxiao新，如果为真输出0，否则输出1[root@docker ~]# [ wanger -ot wangerxiao ] &amp;&amp; echo 0 || echo 10 #比较wanger是否比wangerxiao旧，如果为真输出0，否则输出1 字符串测试：格式： test 字符串测试符 string [ 字符串测试符 string ] [[ 字符串测试符 string ]]常用字符串测试操作符：1234-z string :字符串长度是否为0-n string :字符串长度是否不为0string1 = string2 :string1和string2是否相等string1 != string2 :string1和string2是否不相等 实例：123456789[root@docker ~]# name=wanger #定义一个变量[root@docker ~]# [ -z $name ] &amp;&amp; echo 0 || echo 11 #判断字符串是否为空，为空则返回0，否则返回1[root@docker ~]# test -n $name &amp;&amp; echo 0 || echo 10 #判断字符串是否不为空，如果是则返回0，否则返回1[root@docker ~]# [ $name != &quot;wanger&quot; ] &amp;&amp; echo 0 || echo 11 #判断变量是否不等于”wanger”，如果是返回0,否则返回1[root@docker ~]# test $name = &quot;wanger&quot; &amp;&amp; echo 0 || echo 10 #判断变量是否等于”wanger”,如果是返回0，否则返回1 数值测试：格式：test num1 数值测试操作符 num2[ num1 数值测试操作符 num2 ][[ num 数值测试操作符 num2 ]]((num1数值测试操作符num2)) 常用数值测试操作符：123456num1 -eq num2 : 数字1是否等于数字2num1 -ge num2 : 数字1是否大于等于数字2num1 -gt num2 : 数字1是否大于数字2num1 -le num2 : 数字1是否小于等于数字2num1 -lt num2 : 数字1是否小于数字2num1 -ne num2 : 数字1是否不等于数字2 注意：以上几种操作符不能用在(())格式中，在(())中应使用”&lt; &gt; = != &gt;= &lt;=”比较符号来进行数值的比较 实例：123456789[root@docker ~]# test 6 -le 5 &amp;&amp; echo 0 ||echo 10 #判断6是否小于等于5，如果是返回0，否则返回1[2]+ Done test 64 -gt 63[root@docker ~]# [ 6 -gt 5 ]&amp;&amp; echo 0 || echo 10 #判断6是否大于5，如果大于返回0，否则返回1[root@docker ~]# [[ 6 = 5 ]]&amp;&amp; echo 0 || echo 11 #判断6是否等于5，如果等于返回0，否则返回1[root@docker ~]# ((5!=6))&amp;&amp;echo 0 ||echo 10 #判断5是否等于6，如果不等于返回0，等于则返回1 逻辑运算符：123-a : 相当于&amp;&amp;，表示逻辑与，两端条件都为真，结果为真-o : 相当于||,表示逻辑或，两端条件只要有一个为真，结果就为真！: 逻辑非，两端相反结果为真 实例：1234567test=”123” #定义test变量[root@docker ~]# [ ! -z $test -o $test = &quot;123&quot; ] &amp;&amp;echo 0 || echo 10 #判断test变量是否不为空或者是否等于123，如果是返回0，在[]格式中只能使用-o和-a，而不能用&amp;&amp;和||[root@docker ~]# test -z $test &amp;&amp; test $test = &quot;123&quot; &amp;&amp;echo 0 ||echo 11 #判断test变量是否为空并且test变量是否等于123，如果是返回0[root@docker ~]# [[ -z $test || $test = &quot;123&quot; ]] &amp;&amp;echo 0 ||echo 10 #判断test变量是否为空或者test变量是否等于123，如果是返回0]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程循环脚本]]></title>
    <url>%2F2018%2F08%2F18%2Fshell%E7%BC%96%E7%A8%8B%E5%BE%AA%E7%8E%AF%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[求从1加到100的和使用for循环求和：123456#!/bin/bashdeclare -i sum=0for ((i=1;i&lt;=100;i++));do let sum+=$idoneecho &quot;sum=$sum&quot; 使用until循环求和：123456789#!/bin/bashi=1sum=0until [ $i -gt 100 ];do let sum+=$i let i++doneecho &quot;sum is:$sum&quot; 使用while循环求和：123456789#!/bin/bashi=1sum=0while [ $i -le 100 ];do let sum+=$i let i++doneecho &quot;sum is:$sum&quot; 求100以内的偶数之和使用for循环求和：1234567891011#!/bin/bashi=0sum=0for i in `seq 100` ;do if [ $[$i%2] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is:$sum&quot; 使用while循环求和：123456789101112#!/bin/bashi=0sum=0while [ $i -le 100 ];do let i++ if [ $[$i%2] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is: $sum&quot; 使用until循环求和：123456789101112#!/bin/bashi=0sum=0until [ $i -gt 100 ];do let i++ if [ $[ $i%2 ] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is: $sum&quot; 编写一个九九乘法表使用for循环：123456789#!/bin/bash#for i in `seq 9`;dofor ((j=1;j&lt;=9;j++));do for ((i=1;i&lt;=j;i++));do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; done echodone 使用while循环：12345678910111213#!/bin/bashi=1j=1while[ $j -le 9 ];do while [ $i -le $j ];do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; let i++ done echo let i=1 let j++done 使用until循环：12345678910111213#!/bin/bashi=1j=1until [ $j -gt 9 ];do until [ $i -gt $j ];do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; let i++ done echo let i=1 let j++done 通过脚本判断用户是否登入系统，如果没有，则每10秒循环一次使用while循环：1234567#!/bin/bashread -p &quot;pls input a username: &quot; usernamewhile ! `who |grep &quot;^$username&quot; &amp;&gt; /dev/null`;do sleep 10doneecho &quot;`date +%F-%H:%M:%S` $username logged on&quot;&gt;&gt;/tmp/user.log 使用case循环来获取系统信息1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bashcat &lt;&lt;EOF1) show cpu information;2) show memory information;3) show disk information;4) quitEOFcpu_info()&#123; lscpu &#125;mem_info()&#123; cat /proc/meminfo &#125;disk_info()&#123; fdisk -l &#125;quit()&#123; echo &quot;quit&quot; exit 0 &#125; read -p &quot;pls input a num: &quot; numif [ $num -ne 1 -a $num -ne 2 -a $num -ne 3 -a $num -ne 4 ];then read -p &quot;pls input a num again: &quot; numficase &quot;$num&quot; in 1) cpu_info ;;2) mem_info ;;3) disk_info ;;4) quitesac]]></content>
      <categories>
        <category>shell编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题第一种 markdown最高可以设置六级标题,前面#号的数量代表标题的等级,#号后面要带一个空格123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 演示 一级标题二级标题三级标题四级标题五级标题六级标题第二种 这种只能表示一级和二级标题,=和-的数量没有限制，只要大于一就行1234一级标题=======二级标题------ 演示 一级标题二级标题2.文本样式1234**加粗***斜体* 或者 _斜体_***加粗斜体***~~删除线~~ 演示加粗斜体加粗斜体删除线 3.列表无序列表无序列表可以有三种写法,使用*或+或- :1234567891011121314使用 * ：* 无序列表1* 无序列表2* 无序列表3使用 + ：+ 无序列表4+ 无序列表5+ 无序列表6使用 - ：- 无序列表7- 无序列表8- 无序列表9 演示使用 * ： 无序列表1 无序列表2 无序列表3 使用 + ： 无序列表4 无序列表5 无序列表6 使用 - ： 无序列表7 无序列表8 无序列表9有序列表有序列表就是在前面加数字而不是用符号1231. 有序列表12. 有序列表23. 有序列表3 演示 有序列表1 有序列表2 有序列表34.引用引用的格式很简单,在引用的文字前面加上&gt;就行了12&gt; 为人民服务&gt; ——毛主席 演示 为人民服务 ——毛主席 5.代码块比较短的或是单行的代码可以使用反引号包裹,若是有多行的代码要使用3个反引号,这里为了转义我用\将反引号隔开，顺便说一下,如果不想让一些符号用作markdown语法,可用\进行转义。123456`短的或者单行代码``\`` 多行代码&#123; print ‘人生苦短，我用Python’ &#125;`\`` 演示短的或者单行代码123多行代码&#123; print ‘人生苦短，我用Python’ &#125; 6.表格在markdown里使用表格有点麻烦，使用|来分隔不同的单元格，使用-来分隔表头和其他行，使用:来设置表格的对齐方式:--- 表示左对齐,不加:也表示左对齐:--: 表示居中对齐---: 表示右对齐12345|name|age|sex||:-----|:--:|----:||wanger|23 |nan ||lisi |20 |nv ||wangwu|22 |nan | 演示 name age sex wanger 23 nan lisi 20 nv wangwu 22 nan 7.分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，同时需要在分隔线的上面空一行。123---___*** 演示 8.超链接与图片超链接与图片格式的最大区别就是图片格式多一个’!’，图片的title和链接的title表示你的鼠标指向图片或者链接描述的时候出现的内容,title与图片地址和链接地址之间有空格,title属性可以不加。 图片![图片描述](图片地址 &quot;title&quot;) 链接[链接描述](链接地址 &quot;title&quot;)12![微信公众号](/uploads/wechat-qcode.jpg &quot;微信公众号&quot;)[个人博客](https://wahaha5354.github.io &quot;个人博客&quot;) 演示个人博客]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题的个性化设置]]></title>
    <url>%2F2018%2F08%2F09%2Fnext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[因为hexo博客使用的markdown语法，之前并没有接触过markdown语法，所以第一次写博客只能参考markdown语法的用法来写 设置hexo的头像之前参照了网上修改的方法老是出现报错，折腾了两天还是不行，后来在修改网站图标的时候才知道是因为我配置文件格式写错了，网上的很多方法都是在主题的配置文件里改，但我改了并没有生效，也许是姿势有问题，后来在主题的配置文件里修改竟然生效了，在配置文件里搜索’Sidebar Avatar’，找到如下字段：123456# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg 在url: 后面加上头像的存放地址，我的头像放在了站点目录/source/images/目录下，修改完配置后执行命令:hexo cleanhexo ghexo d 站内搜索刚开始想用Swiftype来着，后来才知道Swiftype在去年就停止免费服务了，又想着去用Algolia，但我实在太笨，找不到地址在哪里，网站访问的也很慢，于是准备用hexo自带的Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 具体可以参考官方的文档Next使用文档目前我的博客评论用的是来必力，分享用的是Add This,站内搜索用的是local search，感觉用起来还是挺不错的]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[后面没有了，这是最早的一篇博客了 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F05%2Ftest%2F</url>
    <content type="text"><![CDATA[hello wanger]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
