<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zabbix配置动作执行远程命令和发送邮件]]></title>
    <url>%2F2019%2F03%2F15%2FZabbix%E9%85%8D%E7%BD%AE%E5%8A%A8%E4%BD%9C%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E5%92%8C%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[当有事件发生，我们可以根据事件来执行相应的动作，根据事件来源可以分为触发器动作，自动发现动作，自动注册动作，内部事件动作，自动发现动作在之前的自动发现那里讲过了，这里介绍一下触发器动作，当触发器事件达到执行动作的必要条件，会执行相应的动作 1.配置邮件告警动作首先创建一个触发器动作，触发报警会发送邮件 定义动作触发条件 定义动作执行的操作，这里是执行发送消息的操作，步骤1-5表示会发送5次消息，默认每次的间隔是30分钟 这里我们定义了1-5步执行的操作，就是每隔30分钟，将消息通过‘zabbix_send.py’这个脚本发送给Admin用户 如果问题两个小时之内没有确认，则会将在两个小时之后每隔十五分钟一次通知zabbix管理组，共发送两次消息 这里看到两个操作的步骤五重叠了，这里较短的自定义步骤持续时间为10分钟的会覆盖较长的步骤持续时间，也就是说第二个操作的5步骤会覆盖第一个操作的5步骤 定义恢复操作，问题解决之后会发送消息给Admin用户 定义更新操作，当其他用户更新问题时收到通知，比如问题被关闭，或者问题严重程度发生变化 到这里动作部分就完成了，如果要让其成功发送邮件，还需要配置用户和报警媒介 配置用户 配置用户报警媒介 配置用户的收件人等信息 创建报警媒介类型 配置报警媒介类型，传入的三个参数分别为收件人，邮件主题，邮件内容 zabbix邮件报警的web界面配置完成了，还需要修改zabbix_server的配置文件，来支持使用脚本vim /etc/zabbix/zabbix_server.confAlertScriptsPath=/usr/lib/zabbix/alertscripts修改完成后重启zabbix-server在/usr/lib/zabbix/alertscripts目录下添加要使用的报警脚本并给邮件授予执行权限chmod +x zabbix_send.py创建一个graph目录，并授予权限mkdir graph chmod 777 -R graph 邮件内容及详细注释如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#!/usr/bin/python#coding=utf-8from email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.mime.image import MIMEImageimport smtplib,sys,os,time,re,requestsfrom smtplib import SMTPuser='Admin' #定义zabbix用户名password='zabbix' #定义zabbix用户密码graph_path='/usr/lib/zabbix/alertscripts/graph' #定义图片存储路径graph_url='http://192.168.179.132/chart.php' #定义图表的url#api_url ="http://10.127.0.119/api_jsonrpc.php" #定义api的url#header = &#123;"Content-Type":"application/json" &#125; #定义api的headersloginurl="http://192.168.179.132/index.php" #定义登录的urlhost='192.168.179.132'to_email=sys.argv[1] #传入的第一个参数为收件人邮箱subject=sys.argv[2] #传入的第二个参数为邮件主题 subject=subject.decode('utf-8')smtp_host = 'smtp.163.com' #定义smtp主机地址from_email = 'wanger@163.com' #定义发件人地址mail_pass = 'asd1234' #发件人邮箱校验码def get_itemid(): #获取报警的itemid itemid=re.search(r'ITEM ID:(\d+)',sys.argv[3]).group(1) return itemiddef get_graph(itemid): #获取报警的图表并保存 session=requests.Session() #创建一个session会话 try: loginheaders=&#123; "Host":host, "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8" &#125; #定义请求消息头 payload = &#123; "name":user, "password":password, "autologin":"1", "enter":"Sign in", &#125; #定义传入的data login=session.post(url=loginurl,headers=loginheaders,data=payload) #进行登录 graph_params=&#123; "from" :"now-10m", "to" : "now", "itemids" : itemid, "width" : "400", &#125; #定义获取图片的参数 graph_req=session.get(url=graph_url,params=graph_params) #发送get请求获取图片数据 time_tag=time.strftime("%Y%m%d%H%M%S", time.localtime()) graph_name='baojing_'+time_tag+'.png' #用报警时间来作为图片名进行保存 graph_name = os.path.join(graph_path, graph_name) #使用绝对路径保存图片 with open(graph_name,'wb') as f: f.write(graph_req.content) #将获取到的图片数据写入到文件中去 return graph_name except Exception as e: print e return Falsedef text_to_html(text): #将邮件内容text字段转换成HTML格式 d=text.splitlines() #将邮件内容以每行作为一个列表元素存储在列表中 html_text='' for i in d: i='' + i + '&lt;br&gt;' html_text+=i + '\n' #为列表的每个元素后加上html的换行标签 return html_textdef send_mail(graph_name): #将html和图片封装成邮件进行发送 msg = MIMEMultipart('related') #创建内嵌资源的实例 with open(graph_name,'rb') as f: #读取图片文件 graph=MIMEImage(f.read()) #读取图片赋值一个图片对象 graph.add_header('Content-ID','imgid1') #为图片对象添加标题字段和值 text=text_to_html(sys.argv[3]) html=""" &lt;html&gt; &lt;body&gt; %s &lt;br&gt;&lt;img src="cid:imgid1"&gt; &lt;/body&gt; &lt;/html&gt; """ % text html=MIMEText(html,'html','utf-8') #创建HTML格式的邮件体 msg.attach(html) #使用attach方法将HTML添加到msg实例中 msg.attach(graph) #使用attach方法将图片添加到msg实例中 msg['Subject'] = subject msg['From'] = from_email try: server=SMTP(smtp_host,"25") #创建一个smtp对象 server.starttls() #启用安全传输模式 server.login(from_email,mail_pass) #邮箱账号登录 server.sendmail(from_email,to_email,msg.as_string()) #发送邮件 server.quit() #断开smtp连接 except smtplib.SMTPException as a: print adef run(): itemid=get_itemid() graph_name=get_graph(itemid) send_mail(graph_name)if __name__ =='__main__': run() 2.配置执行远程命令的动作当触发器达到阈值报警时，我们可以根据相关的报警来执行相关的命令使故障达到自我恢复的效果这里我举一个ssh端口关闭并执行重启ssh的例子 在系统上配置在zabbix客户端配置文件中取消注释下面语句，以支持zabbix客户端执行远程命令vim /etc/zabbix/zabbix_agentd.confEnableRemoteCommands=1zabbix执行远程命令使用的是zabbix用户，确保’zabbix’用户具有已配置命令的执行权限。vim /etc/sudoersDefaults !requiretty #不需要提示终端登录 zabbix ALL=(ALL) NOPASSWD: ALL ＃允许’zabbix’用户在没有密码的情况下运行所有命令。配置完成后，使用zabbix-get测试是否可以运行远程命令，如果返回数据，则表示远程命令可用zabbix_get -s 192.168.179.132 -k “system.run[sudo df -h]” 配置脚本vim /restart_ssh.sh12#/bin/bash systemctl restart sshd 对脚本授予可执行权限chmod +x /restart_sshd.sh 创建ssh的监控项 创建触发器 配置动作创建动作 配置动作触发条件 配置动作执行的命令，这里为了方便查看效果，延迟两分钟执行 触发报警这里关闭ssh服务，使报警触发systemctl stop sshd 报警触发，两分钟后执行脚本这里可以使用zabbix-get来获取监控的值。来查看是否成功执行命令zabbix_get -s 192.168.179.132 -k net.tcp.port[192.168.179.132,22]可以看到，zabbix已经成功执行脚本，重启ssh]]></content>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix发送带有图片的邮件]]></title>
    <url>%2F2019%2F03%2F04%2Fzabbix%E5%8F%91%E9%80%81%E5%B8%A6%E6%9C%89%E5%9B%BE%E7%89%87%E7%9A%84%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[实现思路： 首先报警信息里第一行要有itemid，这是前提，根据信息里传入的参数使用正则匹配到itemid 使用脚本创建一个zabbix会话，来根据itemid来获取图片，并将获取到的图片保存到本地 将传入的参数信息的text字段转换成HTML格式，然后将HTML格式的信息和图片作为邮件进行发送 具体脚本如下： #!/usr/bin/python #coding=utf-8 from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.mime.image import MIMEImage import smtplib,sys,os,time,re,requests from smtplib import SMTP user='Admin' #定义zabbix用户名 password='zabbix' #定义zabbix用户密码 graph_path='/usr/lib/zabbix/alertscripts/graph' #定义图片存储路径 graph_url='http://192.168.179.132/chart.php' #定义图表的url #api_url ="http://10.127.0.119/api_jsonrpc.php" #定义api的url #header = {"Content-Type":"application/json" } #定义api的headers loginurl="http://192.168.179.132/index.php" #定义登录的url host='192.168.179.132' to_email=sys.argv[1] #传入的第一个参数为收件人邮箱 subject=sys.argv[2] #传入的第二个参数为邮件主题 subject=subject.decode('utf-8') smtp_host = 'smtp.163.com' #定义smtp主机地址 from_email = 'wanger@163.com' #定义发件人地址 mail_pass = 'asd1234' #发件人邮箱校验码 def get_itemid(): #获取报警的itemid itemid=re.search(r'ITEM ID:(\d+)',sys.argv[3]).group(1) return itemid def get_graph(itemid): #获取报警的图表并保存 session=requests.Session() #创建一个session会话 try: loginheaders={ "Host":host, "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8" } #定义请求消息头 payload = { "name":user, "password":password, "autologin":"1", "enter":"Sign in", } #定义传入的data login=session.post(url=loginurl,headers=loginheaders,data=payload) #进行登录 graph_params={ "from" :"now-10m", "to" : "now", "itemids" : itemid, "width" : "400", } #定义获取图片的参数 graph_req=session.get(url=graph_url,params=graph_params) #发送get请求获取图片数据 time_tag=time.strftime("%Y%m%d%H%M%S", time.localtime()) graph_name='baojing_'+time_tag+'.png' #用报警时间来作为图片名进行保存 graph_name = os.path.join(graph_path, graph_name) #使用绝对路径保存图片 with open(graph_name,'wb') as f: f.write(graph_req.content) #将获取到的图片数据写入到文件中去 return graph_name except Exception as e: print e return False def text_to_html(text): #将邮件内容text字段转换成HTML格式 d=text.splitlines() #将邮件内容以每行作为一个列表元素存储在列表中 html_text='' for i in d: i='' + i + '&lt;br&gt;' html_text+=i + '\n' #为列表的每个元素后加上html的换行标签 return html_text def send_mail(graph_name): #将html和图片封装成邮件进行发送 msg = MIMEMultipart('related') #创建内嵌资源的实例 with open(graph_name,'rb') as f: #读取图片文件 graph=MIMEImage(f.read()) #读取图片赋值一个图片对象 graph.add_header('Content-ID','imgid1') #为图片对象添加标题字段和值 text=text_to_html(sys.argv[3]) html=""" &lt;html&gt; &lt;body&gt; %s &lt;br&gt;&lt;img src="cid:imgid1"&gt; &lt;/body&gt; &lt;/html&gt; """ % text html=MIMEText(html,'html','utf-8') #创建HTML格式的邮件体 msg.attach(html) #使用attach方法将HTML添加到msg实例中 msg.attach(graph) #使用attach方法将图片添加到msg实例中 msg['Subject'] = subject msg['From'] = from_email try: server=SMTP(smtp_host,"25") #创建一个smtp对象 server.starttls() #启用安全传输模式 server.login(from_email,mail_pass) #邮箱账号登录 server.sendmail(from_email,to_email,msg.as_string()) #发送邮件 server.quit() #断开smtp连接 except smtplib.SMTPException as a: print a def run(): itemid=get_itemid() graph_name=get_graph(itemid) send_mail(graph_name) if __name__ =='__main__': run()]]></content>
  </entry>
  <entry>
    <title><![CDATA[zabbix配置微信和邮件报警]]></title>
    <url>%2F2018%2F12%2F29%2Fzabbix%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[安装并配置mailx安装mailxyum install -y mailx 修改mailx配置文件vim vim /etc/mail.rc12345set from=wang210@163.com #定义发件人set smtp=smtp.163.com #定义smtp服务器set smtp-auth-user=wang210@163.com set smtp-auth-password=asdASD123set smtp-auth=login 发送测试邮件echo &#39;test1&#39;|mail -s &quot;testmail&quot; wang210@126.com 编写邮件告警脚本vim /usr/lib/zabbix/alertscripts/mail.sh这是zabbix默认的脚本路径，可以通过zabbix_server配置文件修改12345#/bin/bashto=$1subject=`echo $2|tr '\r\n' '\n'`message=`echo $3|tr '\r\n' '\n'`echo "$message"|mail -s "$subject" $to &gt;&gt;/var/log/mailx.log 2&gt;&amp;1 touch /var/log/mailx.logchown -R zabbix.zabbix /var/log/mailx.logchmod +x /usr/lib/zabbix/alertscripts/mail.sh./mail.sh wang210@126.com “主题” “内容” 编辑zabbix_web，配置报警媒介脚本参数的变量全为大写，是zabbix内置的宏更多关于zabbix的宏可以查看 官方文档宏的介绍除了使用脚本媒介，也可以使用email作为媒介，相比之下，使用email更简单 编辑zabbix_web,配置用户 配置报警动作操作，恢复操作，或者更新操作必须存在一个 配置条件可以根据自己的需要配置触发条件 配置操作默认标题： 1&#123;TRIGGER.STATUS&#125;:&#123;TRIGGER.NAME&#125; 消息内容： 123456报警主机：&#123;HOST.NAME&#125;报警IP：&#123;HOST.IP&#125;报警时间：&#123;EVENT.DATE&#125;-&#123;EVENT.TIME&#125;报警等级：&#123;TRIGGER.SEVERITY&#125;报警信息：&#123;TRIGGER.NAME&#125;：&#123;ITEM.VALUE&#125;事件ID：&#123;EVENT.ID&#125; 配置恢复操作默认标题： 1&#123;TRIGGER.STATUS&#125;:&#123;TRIGGER.NAME&#125; 消息内容： 123456恢复主机：&#123;HOST.NAME&#125;恢复IP：&#123;HOST.IP&#125;恢复时间：&#123;EVENT.DATE&#125;-&#123;EVENT.TIME&#125;恢复等级：&#123;TRIGGER.SEVERITY&#125;恢复信息：&#123;TRIGGER.NAME&#125;:&#123;ITEM.VALUE&#125;恢复ID：&#123;EVENT.ID&#125; 关闭agent，测试报警systemctl stop zabbix_agentsystemctl start zabbix_agent 配置微信报警注册企业微信配置微信报警需要注册企业微信 获取企业ID点击‘我的企业’到最下面获取 获取AgentID和Secret单击应用与小程序，选择下面的创建应用，应用名字自己随便起，最好有象征意义 然后打开新创建的应用，记录下AgentID和Secret 配置脚本从GitHub克隆微信报警脚本123git clone https://github.com/X-Mars/Zabbix-Alert-WeChat.gitcp Zabbix-Alert-WeChat/wechat.py /usr/local/zabbix34/alertscripts/chmod +x wechat.py &amp;&amp; chown zabbix:zabbix wechat.py 安装requests库使用pip安装，需要先下载pip1python get-pip.py 安装requests库1pip install requests 修改wechat.py脚本Corpid，Secret，Agentid填写自己企业微信的信息，修改这三个参数即可，当然也可以选择使用标签ID，部门ID，取消注释即可 修改完成后测试脚本是否可用12python wechat.py 企业微信ID test text&#123;u&apos;invaliduser&apos;: u&apos;&apos;, u&apos;errcode&apos;: 0, u&apos;errmsg&apos;: u&apos;ok&apos;&#125; 在zabbix_web上配置报警媒介和用户配置报警媒介 配置用户收件人填写企业微信的用户ID 配置动作配置操作消息内容与标题与邮件报警配置相同，只要把发送的媒介通过WeChat发送即可 配置恢复操作恢复操作也是把媒介改成通过WeChat发送 测试微信报警重启虚拟机测试,企业微信收到邮件]]></content>
      <categories>
        <category>zabbix</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础之函数]]></title>
    <url>%2F2018%2F12%2F29%2Fpython%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python函数函数是python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。函数也是一种设计工具，使用函数，我们也可以把复杂的系统分解为可管理的部件 函数的意义 最大化代码重用和最小化代码冗余 流程的分解 函数的相关语句和表达式 语句 例子 Calls my_function(‘Fir Arg’,’Sec Arg’) def def myfunction(fir_arg,sec_arg): return return fir_arg+sec_arg global global x;x=new_value nonlocal nonlocal x;x=new_value yield def my_sqr(x): for i in range(x): yield i **2 lambda funcs=[lambda x: x*2,lambda x:x3] 编写函数def是可执行的代码。在python里，只有def执行之后，才会生成相应的函数。要是def没有执行，相应的函数就不会生成。def语句在if、while语句甚至是其他def语句里也是合法的。 def创建了一个对象，并将其赋值给一个变量。def语句是生成一个函数对象，并将其赋值给函数名变量 lambda创建一个函数对象发送给调用者。因此，也可使用lambda表达式创建函数，这一功能允许我们把函数定义内联到语法上一条def语句不能工作的地方 return将一个结果对象返回给调用者。这个返回值成为函数调用的结果。 yield向调用者返回一个结果对象，但是记住他离开的地方 global声明了一个模块级的变量并被赋值。在默认情况下，所有在函数内被赋值的变量，是在这个函数里的本地变量，并仅在函数运行过程中存在。为分配一个可以在整个模块中都可以使用的变量名，函数需要在global语句中列举出来。 nonlocal声明了将要赋值的一个封闭的函数变量。python3.x里才有的语句。函数里嵌套函数时，都是用相同变量名，只想继承上一个函数里的相同变量时可以使用。 函数是通过赋值（对象引用）传递的。参数是通过赋值传递的。但是在python中赋值就是对象引用。因此当参数被传递的对象为可变对象，当对参数进行变更时，会影响到被传递进来的变量 参数、返回值以及变量并不需要声明。这个与其他变量相同，不需要提前声明。 def语句def语句将创建一个函数并将其赋值给一个变量名：def &lt;变量名&gt;([参数1,参数2,…]): &lt;语句&gt;def语句的首行定义函数名，并引用函数对象，函数名的本质就是函数的内存地址。参数个数是0或以上数目。语句里，可以包含return语句，在调用函数时，会返回一个值。当没有return时，默认返回值为None。函数里，也可以使用yield语句来生成返回值。因为def是执行语句，因此函数是实时生成的 1234567&gt;&gt;&gt; def hanshu(x,y): return x*y&gt;&gt;&gt; hanshu('abc',2)'abcabc'&gt;&gt;&gt; hanshu(2,[1,2,3])[1, 2, 3, 1, 2, 3] 在这个函数里，x*y的结果取决于x和y的对象类型，因为python本身不定义变量，因此传递的值的类型与返回的类型都不一定是固定的类型。 python作用域作用域针对的是变量。在使用同一个变量名时，会出现作用域问题。 一个def内定义的变量名能够被def内部使用。不能在函数外部引用这个变量名。 def内的变量名与def外的变量名并不冲突。在def内赋值的与def外赋值的相同变量名是不同变量。变量名有如下三种不同作用域： 全局：在def外定义的变量名是全局变量 本地：在def内部定义的叫做本地变量 其他：嵌套def时，各自的变量也是独立的。 本地变量与全局变量1234567891011121314151617&gt;&gt;&gt; x=10 #全局变量&gt;&gt;&gt; def funx(): x=20 #本地变量 print(x)&gt;&gt;&gt; print(x) #打印的是全局变量10&gt;&gt;&gt; funx() #打印的是本地变量20&gt;&gt;&gt; x=10&gt;&gt;&gt; def funx(): print(x) #本地变量没有定义的话会引用全局的变量&gt;&gt;&gt; print(x)10&gt;&gt;&gt; funx()10 作用域法则 内嵌的模块是全局作用域 全局作用域的作用范围仅限于单个文件 每次的函数的调用都创建了一个新的本地作用域 赋值的变量名除非声明全局变量或非本地变量，否则均为本地变量 所有其他的变量名都可以归纳为本地全局或者内置。 变量名使用时，查找顺序： 本地变量名——在本地是否使用此变量名赋值过 上一层结构中def或lambda的本地变量名——上一层是否使用此变量名赋值过 全局变量名——在整个文件里是否对变量名赋值过 内置变量名——python内部是否存在此变量名如果找不到以上变量名则会报错 1234567891011121314151617&gt;&gt;&gt; def newdef(): x=20 def newdef2(): print(x) newdef2() &gt;&gt;&gt; newdef()20&gt;&gt;&gt; x=10&gt;&gt;&gt; def newdef(): def newdef2(): print(x) newdef2() &gt;&gt;&gt; newdef()10 global语句在函数内，想改变全局变量，可以使用global语句来定义此变量为全局变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt;&gt;&gt; g='global'&gt;&gt;&gt; l='global'&gt;&gt;&gt; def glo(): global g g='local' l='local' &gt;&gt;&gt; g'global'&gt;&gt;&gt; l'global'&gt;&gt;&gt; glo()&gt;&gt;&gt; g'local'&gt;&gt;&gt; l'global'``` 在glo函数里，都重新赋值了g与l,但在函数执行后只有g改变了，当使用global之后，当前函数里所使用的所有对变量g的更改都会对全局变量g进行更改。除了这个方法，还有引用自己的方法（交互模式里，可以import __main__）与sys.modules的方法（可以使用引用过的所有模块，交互模式里本身可用__main__方式）。```python&gt;&gt;&gt; x=10&gt;&gt;&gt; import __main__&gt;&gt;&gt; __main__.x10&gt;&gt;&gt; def glo(): __main__.x+=1 &gt;&gt;&gt; glo()&gt;&gt;&gt; x11&gt;&gt;&gt; s=10&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules['__main__'].s10&gt;&gt;&gt; def glo(): sys.modules['__main__'].s+=1 &gt;&gt;&gt; glo()&gt;&gt;&gt; s11 作用域与嵌套函数被嵌套函数的作用域就是上级函数，在这里，想调用inner函数，必须是在函数outer里面，不能直接使用。可以使用返回内部函数的方法来提取内部函数： 1234567&gt;&gt;&gt; def outer(): def inner(): print('inner') inner() &gt;&gt;&gt; func1=outer()inner 工厂函数工厂函数：根据要求的对象，一个能够记住嵌套作用域的变量值的函数。123456789101112131415161718192021222324252627282930&gt;&gt;&gt; def printx(x): def printy(y): #嵌套函数 return x*y #返回x*y的值 return printy #返回嵌套的函数&gt;&gt;&gt; a=printx(3) #定义x值为3后的嵌套函数赋值&gt;&gt;&gt; a(2)6&gt;&gt;&gt; a(3)9``` #### nonlocal语句nonlocal让内部函数中的变量在上一层及以下层函数中生效（父级级父级以下）```pythonx=1&gt;&gt;&gt; def func1(): x=2 def func2(): nonlocal x x=3 return x func2() print(x)&gt;&gt;&gt; func1()3&gt;&gt;&gt; x1 因为x并不是全局变量，所以只有在调用函数时nonlocal语句才会生效，这里x=3，当直接输出x而不调用函数时那么x=1 参数参数简介参数：argement或parameter，对象作为输入值传递给函数的方式。参数传递时的简要关键点： 参数的传递是通过自动将对象赋值给本地变量名来实现 在函数内部的参数名的赋值不会影响调用者 改变函数的可变对象参数的值也许会对调用者有影响 传递参数为可变对象与不可变对象时：不可变对象通过值进行传递——数值、字符串等可变对象是通过指针进行传递——列表、字典等 1234567891011&gt;&gt;&gt; a=3&gt;&gt;&gt; def printa(a): a=a+1 print(a)&gt;&gt;&gt; a3&gt;&gt;&gt; printa(a)4&gt;&gt;&gt; a3 参数传递在这里，b[:]方式会新生成一个列表对象，因此函数里的y与setlist(b[:])是两个不同的对象。这种方法可以避免可变参数的修改。12345678910&gt;&gt;&gt; def setlist(y): y.append(3) &gt;&gt;&gt; a=[1,2]&gt;&gt;&gt; setlist(a[:])&gt;&gt;&gt; a[1, 2]&gt;&gt;&gt; setlist(a)&gt;&gt;&gt; a[1, 2, 3] 参数传递是由特定匹配规则的： 位置：从左到右 关键字参数：通过参数名进行匹配 默认参数：为没有传入值得参数定义参数值 可变参数：收集任意多基于位置或关键字的参数——参数以* 或**开头 可变参数解包：传递任意多的基于位置或关键字的参数——传递值以* 或**开头 Keyword-only参数：参数必须按照名称传递 传递参数时，要注意顺序：非关键字参数-&gt;关键字参数-&gt;字典参数 1234567&gt;&gt;&gt; def myfunc(a,b): print(a,b)&gt;&gt;&gt; myfunc(1,2)1 2&gt;&gt;&gt; myfunc(b=1,a=2)2 1 匹配语法 语法 位置 func(value) 调用者 常规参数：通过位置进行匹配 func(name=value) 调用者 关键字参数：通过变量名匹配 func(*sequence) 调用者 迭代传递所有元素 func(**dict) 调用者 以‘键’为关键字，‘值’为相应值的方式传递字典所有元素 def func(name) 函数 常规参数：通过位置或变量名进行匹配 def func(name=value) 函数 默认参数值：如果没有在调用中传递的话 def func(*name) 函数 匹配并收集（在元组中）所有包含位置的参数 def func(**name) 函数 匹配并收集（在字典中）所有包含关键字的参数 def func(*arg,name) 函数 参数必须在调用中按照关键字传递 常规参数函数用法：123456&gt;&gt;&gt; def myfunc(a,b): result=a+b print(result)&gt;&gt;&gt; myfunc(1,2)3 关键字参数函数： 123456&gt;&gt;&gt; def myfunc(a,b): result=a+b print(result)&gt;&gt;&gt; myfunc(b=1,a=3)4 迭代传递参数用法：123456&gt;&gt;&gt; def myfunc(a,b,c): result=a+b+c print(result) &gt;&gt;&gt; myfunc(*[1,2,3])6 在字典中匹配所有参数用法：12345678&gt;&gt;&gt; def myfunc(a,b,c): result=a+b+c print(result)&gt;&gt;&gt; myfunc(**&#123;'a':1,'b':2,'c':3&#125;)6&gt;&gt;&gt; myfunc(1,**&#123;'b':2,'c':3&#125;)6 默认参数函数用法：1234567&gt;&gt;&gt; def myfunc(a,b=3): print(a+b) #当有默认参数存在时，可以只传入其他的参数&gt;&gt;&gt; myfunc(3)6&gt;&gt;&gt; myfunc(3,2)5 可变参数函数用法：可变参数，可以传递任意个参数*args方式是把所有常规参数调用与迭代调用放进一个元组里：12345678&gt;&gt;&gt; def myfunc(*a): result=''.join(a) print (result)&gt;&gt;&gt; myfunc('1,','2,','3')1,2,3&gt;&gt;&gt; myfunc('first,',*['second,','third'])first,second,third **args方法是把任意个关键字参数与字典调用方式存放在变量名为args的字典里1234567&gt;&gt;&gt; def myfunc(**a): print(a)&gt;&gt;&gt; myfunc(a='1',b='2')&#123;'a': '1', 'b': '2'&#125;&gt;&gt;&gt; myfunc(a='1',b='2',**&#123;'c':'3'&#125;)&#123;'a': '1', 'b': '2', 'c': '3'&#125; 必须使用关键字传递的方法：函数里的参数：常规——有/无默认值args——存放在列表**args——存放在字典在python3开始，在args与args中间可以加入一个“必须使用关键字传递的参数”使用方法为是0个或多个常规参数+或args+“必须使用关键字传递的参数”+0个或1个args。12345678910&gt;&gt;&gt; def myfunc(*,b,**c): print(b,c)&gt;&gt;&gt; myfunc(**&#123;'b':4&#125;)4 &#123;&#125;&gt;&gt;&gt; def myfun(*a,b,**c): print(a,b,c)&gt;&gt;&gt; myfun(2,**&#123;'b':4,'c':5&#125;)(2,) 4 &#123;'c': 5&#125; 特殊参数的传递：在python里，函数也是对象，函数名也是变量名，因此函数本身也可以传递。计算最大、最小值的函数时，一般用法：12345678910111213141516171819202122232425262728#这是一个求最小值的函数&gt;&gt;&gt; def min1(*a): reg=a[0] for i in a[1:]: if i &lt;reg: reg=i print(reg) &gt;&gt;&gt; min1(2,3,5,1,6,8)1#这里将最大和最小值的函数作为参数传入到求最大和最小值的函数里&gt;&gt;&gt; def lessthan(x,y): return x&lt;y&gt;&gt;&gt; def morethan(x,y): return x&gt;y&gt;&gt;&gt; def minmax(test,*args): res=args[0] for i in args[1:]: if test(i,res): res=i print(res)&gt;&gt;&gt; minmax(lessthan,2,3,5,1,6)1&gt;&gt;&gt; minmax(morethan,2,3,5,1,6)6 函数的高级用法递归函数1234567891011&gt;&gt;&gt; def mysum(s): if not s: return 0 else: return s[0]+mysum(s[1:])#或&gt;&gt;&gt; def mysum(s): return 0 if not s else s[0]+mysum(s[1:]) &gt;&gt;&gt; mysum([1,2,3,4])10 嵌套列表里面的值相加123456789101112&gt;&gt;&gt; li=[1,2,[3,4,5],6,[7,[8,9],10]]&gt;&gt;&gt; def sumlist(a): sum=0 for i in a: if not isinstance(i,list): #判断遍历的i是否是列表 sum += i else: sum += sumlist(i) return sum&gt;&gt;&gt; sumlist(li)55 函数对象：属性和注解在python里函数也是以对象的形态出现。函数名也是以变量名形式存放。因此函数也可以跨模块，以参数传递等形式。函数对象也能调用根本无关的操作：属性存储与注释。间接函数调用：123456&gt;&gt;&gt; def func(x): print(x) &gt;&gt;&gt; func2=func&gt;&gt;&gt; func2(2)2 把函数放进列表或元组里：12345678910111213&gt;&gt;&gt; def myfunc(func_name,arg1): func_name(arg1)&gt;&gt;&gt; def func_name(arg1): print (arg1) &gt;&gt;&gt; li=[(func_name,1),(func_name,2),(func_name,3)]&gt;&gt;&gt; for i in li: myfunc(i[0],i[1])123 匿名函数：lambdalambda会生成函数对象，但不赋值给任何变量。lambda表达式：lambda [&lt;arg1&gt;][,&lt;arg2&gt;][,&lt;arg3&gt;]….:expression using args参数不是必须的，但没有参数就没有相对意义。lambda简单说明：lambda是一个表达式，而不是一个语句，也不是一个的代码块。——生成一个对象。12345&gt;&gt;&gt; myfunc=lambda a:a*2&gt;&gt;&gt; myfunc(4)8&gt;&gt;&gt; (lambda a,b:a*b)(5,4)20 当我们把函数对象放进列表里等操作的时候，使用def感觉很臃肿，这时可以使用lambda来简化过程。1234567&gt;&gt;&gt; funclist=[lambda x: x**2, lambda x: x**3, lambda x: x**4]&gt;&gt;&gt; funclist[0](2)4&gt;&gt;&gt; funclist[1](3)27 在序列中映射函数：map使列表中的每个值都加10123&gt;&gt;&gt; l=[1,2,3,4]&gt;&gt;&gt; list(map(lambda x: x+10,l))[11, 12, 13, 14] 函数式编程工具：filterfilter与map相似，但是针对返回的bool结果判断，结果为真，保留元素；结果为假，弃用元素。结果也是保存在可迭代对象里：12&gt;&gt;&gt; list(filter(lambda x: x&gt;1,[-1,0,1,2,3,4,5]))[2, 3, 4, 5] 函数式编程工具：reducereduce函数是在functools模块里的，因此我们需要导入这个函数。这个方法是第一次从可迭代对象里提取两个元素当作函数的参数传入，按前面的函数进行运算，保存返回值，当可迭代对象里还有元素的时候，之前的返回值为第一个参数，可迭代对象里取下一个继续运算，知道可迭代对象空。最后返回函数的返回值。12345&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x,y: x+y,[1,2,3,4])10&gt;&gt;&gt; reduce(lambda x,y:x if x&gt;y else y,[3,5,2,6,7,4,1,9])9]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用LNMP搭建zabbix并对接elasticsearch]]></title>
    <url>%2F2018%2F12%2F22%2F%E4%BD%BF%E7%94%A8LNMP%E6%90%AD%E5%BB%BAzabbix%E5%B9%B6%E5%AF%B9%E6%8E%A5elastic%2F</url>
    <content type="text"><![CDATA[安装zabbix-server添加zabbix存储库123rpm -ivh https://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpmyum -y install yum-utilsyum-config-manager --enable rhel-7-server-optional-rpm 安装zabbix-server zabbix-web12yum install zabbix-server-mysqlyum install zabbix-web-mysql 安装MySQL5.7数据库卸载mariadb包12rpm -qa |grep mariadb #查看当前安装的mariadb的包rpm -e --nodeps mariadb-libs-5.5.52-1.el7.x86_64 #卸载mariadb的包 下载并解压MySQL源码包123wget https://dev.mysql.com/get/archives/mysql-5.7/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz #从官网下载源码包tar -xzvf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz #解压源码包mv mysql-5.7.21-linux-glibc2.12-x86_64 /usr/local/mysql 创建MySQL用户并对MySQL文件进行授权123groupadd mysql --创建mysql用户组useradd -r -g mysql mysql --创建mysql用户并添加到mysql用户组中chown -R mysql.mysql mysql/ --将mysql目录访问权限赋为myql用户 创建MySQL配置文件123456789101112131415161718cat &gt;&gt;/etc/my.cnf &lt;&lt;EOF #写入配置文件[client]port = 3306socket = /tmp/mysql.sock[mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos;basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/tmp/mysql.socklog-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid#不区分大小写lower_case_table_names = 1sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTIONmax_connections=5000default-time_zone = &apos;+8:00‘EOF 初始化数据库1234touch /var/log/mysqld.log #创建日志文件并授权chmod 777 /var/log/mysqld.logchown mysql.mysql mysqld.log/usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data 查看初始化密码1cat /var/log/mysqld.log|grep root@localhost 执行如下操作开启MySQL服务，并设置相应权限12345mkdir /var/run/mysqldtouch /var/run/mysqld/mysqld.pidchmod -R 777 /var/run/mysqldchown -R mysql.mysql /var/run/mysqld/usr/local/mysql/support-files/mysql.server start #启动MySQL 修改MySQL密码vim /etc/my.cnf #修改配置文件12345678skip-grant-tables #跳过密码认证default_password_lifetime=360 #修改密码超时时间不然修改密码之后密码会过期，会提示让你重新设置密码You must reset your password using ALTER USER statement before executing this statement./usr/local/mysql/bin/mysql -uroot -p #登录MySQLuse mysql #切换MySql数据库update mysql.user set authentication_string =password(&apos;root&apos;), host = &apos;%&apos; where user = &apos;root&apos;; #修改MySQL密码flush privileges; 将MySQL加入环境变量12echo &apos;PATH=/usr/local/mysql/bin:$PATH&apos; &gt;&gt;/etc/profile #将MySQL二进制文件加入环境变量ln -s usr/local/mysql/support-files/mysql.server /usr/local/mysql/bin/ 将MySQL的启动文件软连接到MySQL的环境变量中 进入数据库并创建zabbix数据库以及创建授权用户123mysql&gt; create database zabbix character set utf8 collate utf8_bin;mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix&apos;；mysql&gt; flush privileges; 编辑zabbix-server配置文件修改以下参数为创建数据库时的信息，并重启zabbix-servervim /etc/zabbix/zabbix_server.conf123456DBName=zabbixDBHost=192.168.179.132DBUser=zabbixDBPassword=zabbixsystemctl enable zabbix-serversystemctl start zabbix-server 启动的时候启动失败，查看系统日志，查找关键词1usr/sbin/zabbix_server: error while loading shared libraries: libmysqlclient.so.18: cannot open shared object file: No such file or directory 原来是缺少一个文件，yum安装解决yum -y install mysql-libs 将初始数据导入MySQL中1zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix 安装Nginx关掉防火墙和selinux123systemctl stop firewalldsystemctl disable firewalldsed -i &apos;s/SELINUX=enforcing/SELINUX=disable/g&apos; /etc/selinux/config 安装依赖12yum -y install wget vim lsof lrzsz pcre-devel zlib-devel make gd-devel libjpeg-devel libpng-devel libxml2-devel bzip2-devel libcurl-devel libmcrypt libmcrypt-devel mcrypt mhash net-snmp-develyum -y install gcc bison bison-devel openssl-devel readline-devel libedit-devel sqlite-devel freetype freetype-devel libevent-devel mysql-devel 配置Nginx的yum仓库123456789cat &gt;&gt;/etc/yum.repos.d/nginx.repo &lt;&lt;EOF[nginx]name=nginx.repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1skip_if_unavailable = 1keepcache = 0EOF 启动Nginx123nginx -t 测试配置是否有错systemctl start nginxsystemctl enable nginx 安装PHP添加PHP用户useradd -s /sbin/nologin php-fpm 安装PHP依赖库1yum install -y gcc gcc-c++ make zlib zlib-devel pcre pcre-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers 编译安装php1234567wget http://mirrors.sohu.com/php/php-7.2.6.tar.gztar zxvf php-7.2.6.tar.gzcd php-7.2.6./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --with-fpm-user=php-fpm --with-fpm-group=php-fpm --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --with-libxml-dir --with-gd --with-jpeg-dir --with-png-dir --with-freetype-dir --with-iconv-dir --with-zlib-dir --with-mcrypt --enable-soap --enable-gd-native-ttf --enable-ftp --enable-mbstring --enable-exif --disable-ipv6 --with-pear --with-curl --enable-bcmath --enable-mbstring --enable-sockets --with-gd --with-libxml-dir=/usr/local --with-gettextmake &amp;&amp; make installecho $? #每执行完上条命令就运行一下，如果返回0，则执行成功cp php.ini-production /usr/local/php/etc/php.ini 更改PHP配置文件123456sed -i &apos;s/post_max_size = 8M/post_max_size = 32M/g&apos; /usr/local/php/etc/php.inised -i &apos;s/upload_max_filesize = 2M/upload_max_filesize = 50M/g&apos; /usr/local/php/etc/php.inised -i &apos;s/;date.timezone =/date.timezone =PRC/&apos; /usr/local/php/etc/php.inised -i &apos;s/max_execution_time = 30/max_execution_time = 600/g&apos; /usr/local/php/etc/php.inised -i &apos;s/max_input_time = 60/max_input_time = 600/g&apos; /usr/local/php/etc/php.inised -i &apos;s/memory_limit = 128M/memory_limit = 256M/g&apos; /usr/local/php/etc/php.ini 启动php-fpm123cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.confcp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf vim phpinfo.php123&lt;?phpphpinfo();?&gt; 测试是否能连接nginx，这里出现一个错误，访问动态页面一直显示文件没有发现，修改nginx配置文件的PHP脚本路径变量和修改文件权限后一直没有用，后来我将路径的变量去掉，添加网站真实路径后解决 安装zabbix-agent123yum install zabbix-agentvim /etc/zabbix/zabbix-agentd.conf #Server和ServerActive分别代表zabbix的被动模式和主动模式，这里都填server端的IP最后一行是开启脚本采集数据 安装zabbix-web将zabbix的php源文件拷贝到网站目录上1cp -r /usr/share/zabbix/.* /usr/share/nginx/html/ 修改nginx配置egrep -v ‘(^.*#|^$)’ /etc/nginx/conf.d/default.conf123456789101112131415161718server &#123; listen 80; server_name 192.168.179.132; access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm index.php; &#125; error_page 404 /404.html; location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html$fastcgi_script_name; include fastcgi_params; &#125;&#125; 重启nginx访问会报这个错百度之后得知是权限不足引起的，运行一下命令可以解决，这里一定要777，不然到时候安装完成不能创建配置文件1chmod -R 777 /etc/zabbix/web 在访问浏览器的时候不出图，请教我学长之后得出是因为nginx上配置了图片缓存，去掉缓存解决 访问192.168.179.132/index.php安装zabbix-web安装完成可能会遇到连接不上zabbix-server的错误，查看zabbix-server日志如下，这个解决方法有两种，第一种就是创建一个mysql.sock然后重启mysql服务器12mkdir /var/lib/mysqlln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock 第二种就是编辑zabbix_server.conf文件，将DBSocket修改为自己数据库的mysql.sock,然后重启 zabbix_server 监控zabbix 本机的CPU idle监控CPU idle基本就是图形界面，创建监控项之前先测试一下key值是否可用，当然需要安装zabbix_get工具，使用yum install zabbix-get来安装1zabbix_get -s 192.168.179.132 -k system.cpu.util[all,idle,avg1] 自建模板监控磁盘IO监控磁盘IO利用的工具是iostatyum install -y sysstat 首先zabbix-agent端要开启允许脚本收集监控数据编辑zabbix-agent的配置文件vim /etc/zabbix/zabbix_agentd.d/userparameter.conf1UserParameter=disk.status[*],/usr/local/zabbix/scripts/disk-status.sh $1 编写收集脚本vim /usr/local/zabbix/scripts/disk-status.sh12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bash if [ $# -ne 1 ];then echo "Follow the script name with an argument" ficase $1 in rrqm) iostat -dxk 1 1|grep -w sda |awk '&#123;print $2&#125;' ;; wrqm) iostat -dxk 1 1|grep -w sda |awk '&#123;print $3&#125;' ;; rps) iostat -dxk 1 1|grep -w sda|awk '&#123;print $4&#125;' ;; wps) iostat -dxk 1 1|grep -w sda |awk '&#123;print $5&#125;' ;; rKBps) iostat -dxk 1 1|grep -w sda |awk '&#123;print $6&#125;' ;; wKBps) iostat -dxk 1 1|grep -w sda |awk '&#123;print $7&#125;' ;; avgrq-sz) iostat -dxk 1 1|grep -w sda |awk '&#123;print $8&#125;' ;; avgqu-sz) iostat -dxk 1 1|grep -w sda |awk '&#123;print $9&#125;' ;; await) iostat -dxk 1 1|grep -w sda|awk '&#123;print $10&#125;' ;; svctm) iostat -dxk 1 1|grep -w sda |awk '&#123;print $13&#125;' ;; util) iostat -dxk 1 1|grep -w sda |awk '&#123;print $14&#125;' ;; *) echo -e "\e[033mUsage: sh $0 [rrqm|wrqm|rps|wps|rKBps|wKBps|avgqu-sz|avgrq-sz|await|svctm|util]\e[0m"esac touch +x /usr/local/zabbix/scripts/disk-status.sh #给脚本添加执行权限 打开zabbix-web，创建模板浏览器打开192.168.179.132/index.php依次点击配置——&gt;模板——&gt;创建模板添加模板名称以及群组，最后点击添加 创建应用集在创建的模板上点击创建应用集，名字最好与磁盘io相关 创建监控项这里所有的数据类型都是浮点数 创建图形这需要为每一个监控项都创建图形 为需要监控的主机链接模板点击需要监控的主机，然后单击模板，为主机添加模板链接 解决图形名字乱码问题可以看到我收集到的图形是乱码的首先查看zabbix字体目录，它定义的路径是“fonts”，它是一个相对路径，绝对路径为/usr/share/zabbix/fonts，vim /usr/share/zabbix/include/defines.inc.php //搜索ZBX_FONTPATH而字体文件为“ZBX_GRAPH_FONT_NAME”所定义的“graphfont”，它是一个文件，绝对路径为/usr/share/zabbix/fonts/graphfont.ttf我们可以从Windows系统中选择一个中文字体然后放到zabbix的字体目录下Windows字体目录位于C:\Windows\Fonts下，找到仿宋常规字体将他拷入zabbix字体目录下然后修改PHP文件，将字体文件修改为simsong 安装elastic6.1下载源码包并解压，修改es配置123yum install java #elastic需要安装Java依赖curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.1.4.tar.gztar -xvf elasticsearch-6.1.4.tar.gz vim /root/elasticsearch-6.1.4/config/elasticsearch.yml #主要修改es的一些配置信息启动过程出现的报错1[WARN ][o.e.b.BootstrapChecks ] [PWm-Blt] max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536] 解决办法：vim /etc/security/limits.conf1234* soft nofile 65536* hard nofile 131072* soft nproc 2048* hard nproc 4096 1[WARN ][o.e.b.BootstrapChecks ] [PWm-Blt] max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 解决办法：vim /etc/sysctl.confvm.max_map_count=655360修改完成执行命令：sysctl -pcd elasticsearch-6.1.4/bin这里不能使用root用户运行elastic，可以自己新建一个普通用户，还要把目录授予普通用户权限./elasticsearch然后我们可以打开浏览器输入192.168.179.133:9200可以查看es的状态，或者可以装一个head插件 安装head插件安装node.js这里我采用的源码安装，其实二进制安装是比较简单的，但我执行到最后node的二进制文件无法执行，因此只能源码安装，时间有点长，打了两局王者荣耀才装完123456yum groupinstall "Development Tools" #安装编译必要的工具wget https://nodejs.org/dist/v8.11.4/node-v8.11.4.tar.gz #下载node的源码包tar -zxvf node-v8.11.4.tar.gz #解压源码包cd node-v8.11.4./configure &amp;&amp; make &amp;&amp; make install #执行编译安装echo $? #查看执行结果，输出0表示安装成功 node.js默认安装路径在/usr/local/bin/目录下 安装gruntgrunt是基于Node.js的项目构建工具，可以进行打包压缩、测试、执行等等的工作，head插件就是通过grunt启动npm install -g grunt-cli 下载并安装head插件1234git clone git://github.com/mobz/elasticsearch-head.git #克隆head插件仓库cd elasticsearch-head/npm install #执行完会报一些错误，不要管执行下一条命令就会解决npm install phantomjs-prebuilt@2.1.14 --ignore-scripts 修改elasticsearch的配置vim /elasticsearch/elasticsearch-6.4.0/config/elasticsearch.yml12http.cors.enabled: true # elasticsearch中启用CORShttp.cors.allow-origin: &quot;*&quot; # 允许访问的IP地址段，* 为所有IP都可以访问 启用head插件并在浏览器上打开npm run start #启动head插件在浏览器输入http://192.168.179.133:9100/ 即可使用head插件 使用es存储zabbix的历史数据修改/etc/zabbix/zabbix_server.conf添加如下内容123HistoryStorageURL=192.168.179.133:9200HistoryStorageTypes=str,text,log,uint,dblHistoryStorageDateIndex=1 修改/etc/zabbix/web/zabbix.conf.php添加如下内容1234global $DB, $HISTORY;$HISTORY[&apos;url&apos;] = &apos;http://192.168.179.133:9200&apos;;// Value types stored in Elasticsearch.$HISTORY[&apos;types&apos;] = [&apos;str&apos;, &apos;text&apos;, &apos;log&apos;,&apos;uint&apos;,&apos;dbl&apos;]; 修改完成后重启zabbix,并查看zabbix是否有数据systemctl restart zabbix-server至此，es收集zabbix历史数据完成]]></content>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的语句与语法]]></title>
    <url>%2F2018%2F12%2F20%2FPython%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python的语句与语法 语句 角色 例子 赋值 创建引用值 a=’Apple’,b=’bike’ 调用 执行函数 log.write(‘mylog’) 打印调用 打印对象 print(1,’hello’) if/elif/else 选择动作 if a in b: print(a) for/else 序列迭代 for i in list: print(i) while/else 一般循环 while True: print(‘True’) pass 空占位符 for i in list: pass break 循环/迭代退出 while True:if a==b: break continue 循环继续 for i in list: if i&lt;5: continue def 函数定义 def add(a,b): print(a+b) return 函数返回 def add(a,b): return a+b import 模块访问 import os from 属性访问 from sys import stdin class 创建类 class myclass(): def myprint(): print(‘myprint’) try/except/finally 捕获异常 try: open(‘/tmp/file’) except: print(‘no file’) raise 触发异常 raise &lt;’error type’&gt; assert 调试检查 assert a&lt;0,’a is too large’ with/as 环境管理器 with open(file) as f: f.read() del 删除引用 del_list[i] del_list[i:j] del obj.attr Python语句的格式语句的开头在python里是不使用{}或者别的符号来限制语句的开始和结尾的，一个语句的开始(除了复合语句)，就是开头，换行就是结束。在开头，不能随意增加空格：1234567&gt;&gt;&gt; print (1)1&gt;&gt;&gt; print (1) File "&lt;stdin&gt;", line 1 print (1) ^IndentationError: unexpected indent 语句的对齐在复合语句里也是同样的，当你使用缩进时，必须一致：1234567&gt;&gt;&gt; def add(str):... str=str... print(str) File "&lt;stdin&gt;", line 3 print(str) ^IndentationError: unindent does not match any outer indentation 复合语句复合语句有单行写法和多行写法。从冒号后面就是复合语句的开始。单行：复合语句只有一行时，可使用单行写法，但是复合语句所包含的语句不是单行时，需要使用对齐的缩进来表示复合语句12345678910#单行语句&gt;&gt;&gt; if 1&gt;0: print(1)...1#多行语句&gt;&gt;&gt; if 1&gt;0:... int=1... print(int)...1 语句的结束一般语句里，一行的结束就是此语句的结束。在简单语句可以使用分号来隔开多个语句。12&gt;&gt;&gt; a=3;b=3;print(a+b)6 使用列表，元组，字典的时候按照一定的方式可以把一个语句分成多行:12&gt;&gt;&gt; dict=&#123;1:'first',... 2:'second'&#125; 处理错误当我们所写的语句有bug，会出现一些错误，程序会中断运行。但我们在这个时候，不想让程序中断但还是需要提示报错的时候可以使用try:12345678910111213&gt;&gt;&gt; while True: _input=input("please input digit:") try: print("&#123;:d&#125; *10 is &#123;:d&#125;".format(int(_input),int(_input)*10)) break except: print("&#123;&#125; is not a number".format(_input)) please input digit:aa is not a numberplease input digit:11 *10 is 10 变量赋值变量命名规则变量名可以使大小写字母，数字和下划线，但只能以大小写字母和下划线开头，不能以数字开头。变量名是区分大小写的，保留字符是不能使用的。python3.0里的保留字符：false class finally isNone continue for lambdaTrue def from nonlocaland del dlobal notas elif if orassert else import passbreak except in raise特殊变量名：main等，前后都有两个下划线的变量名，有很多是有特殊意义的 打印print 函数从python3.0开始print变成了函数，但返回值为None，print函数的格式如下：print([object,…][,sep=’’][,end=’\’][file=sys.stdout])在这里，object是要打印的内容。object可以是任意对象。默认是没有。sep是两个object之间隔开的字符。默认是一个空格。end是结尾，默认为换行。file为输出目标，默认为标准输出流。1234567891011121314151617&gt;&gt; print(1,2,3,sep=';')1;2;3&gt;&gt;&gt; print(1,2,3,sep=':')1:2:3&gt;&gt;&gt; print(1,2,3,end='')1 2 3&gt;&gt;&gt; print(1,2,3,end='');print (4,5,6,end='')1 2 34 5 6&gt;&gt;&gt; print(1,2,3,end='\n');print (4,5,6,end='')1 2 34 5 6&gt;&gt;&gt; print(1,2,3,file=open(r'D:\ruanjian\1.txt','wt'))&gt;&gt;&gt; file=open(r'D:\ruanjian\1.txt') &gt;&gt;&gt; file.read() '1 2 3\n' 判断语句真值测试在if语句里的&lt;’test’&gt;位置里的就是判断语句，结果为True，就能进入子语句，判断语句包含： 比较运算符：==,!=,&gt;,&lt;,&gt;=,&lt;= 逻辑运算符：and,or,not 成员运算符：in，not in 身份运算符：is，is not 其他：对象为空，0，None等的时候是False,其他为True123456789101112131415161718&gt;&gt;&gt; 1&lt;2True&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; 1 and TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; 1 in [1,2]True&gt;&gt;&gt; 1 in (1,2)True&gt;&gt;&gt; 1 in &#123;'1':1&#125;False 逻辑运算符当我们使用and和or的时候，返回结果不一定是True或False:and:当其中一个或多个测试值为false的时候，取第一个false的值123False&gt;&gt;&gt; 1 and [] and &#123;&#125;[] and:当全部值得测试值为True的时候，取最后一个值123456&gt;&gt;&gt; 1 and 2 and TrueTrue&gt;&gt;&gt; 1 and 2 and TrueTrue&gt;&gt;&gt; 1 and 2 and True and 33 or:当其中一个或多个值为True的时候，取第一个True的值1234&gt;&gt;&gt; 0 or [1] or &#123;1:'1'&#125;[1]&gt;&gt;&gt; 1 or 0 or 21 or:当全部值为false的时候，去左后一个false值1234&gt;&gt;&gt; 0 or [] or &#123;&#125;&#123;&#125;&gt;&gt;&gt; False or 0 or &#123;&#125;&#123;&#125; 三元表达式三元表达式的格式如下：&lt;’value1’&gt;if &lt;’’test’&gt; else &lt;’value2’&gt;当测试值为真的时候取&lt;’value1’&gt;,假的时候取&lt;’value2’&gt;12345678&gt;&gt;&gt; 1 if True else 21&gt;&gt;&gt; 1 if False else 22&gt;&gt;&gt; 'True' if 1&gt;2 else 'False''False'&gt;&gt;&gt; 'True' if 1&lt;2 else 'False''True' 这个还可以如下运用：[&lt;’value2’&gt;,&lt;’value1’&gt;][&lt;’test’&gt;]12345678&gt;&gt;&gt; [2,1][True]1&gt;&gt;&gt; [2,1][False]2&gt;&gt;&gt; ['False','True'][1&gt;2]'False'&gt;&gt;&gt; ['False','True'][1&lt;2]'True' while语句whil语句一般格式：1234while &lt;'test1'&gt;: &lt;'statement1'&gt;else: &lt;'statement2'&gt; 只要测试语句为真，会一直循环&lt;’statement1’&gt;。当test1为假的时候会运行else语句里的内容。从这里，退出循环的方法有：1.在&lt;’statement1’&gt;里的语句更改&lt;’test1’&gt;的结果为False2.在&lt;’statement1’&gt;里的语句里增加break语句来跳出循环3.在&lt;’statement1’&gt;里的语句里增加exit()来退出python循环，不过这里会退出整个的python程序 例子123456&gt;&gt;&gt; a=0;b=10&gt;&gt;&gt; while a&lt;b: print(a,end='') a+=10123456789 break,continue语句break语句用来退出最近所在的for语句或while语句。continue语句是用来跳到最近所在的for语句或者while语句的结尾。12345678&gt;&gt;&gt; a=0;b=10&gt;&gt;&gt; while a&lt;b: a+=1 if a==3: continue if a ==7: break print (a,end='')12456 pass语句pass语句是占位的空语句，在有些复合语句里，可能没有具体的语句，但需要正常运行，这就需要设置空语句（pass）来代替例子12345&gt;&gt;&gt; if True: print('true')else: passtrue else语句else语句，只有在for语句和while语句正常结束后，会运行：12345678&gt;&gt;&gt; a=0;b=10&gt;&gt;&gt; while a&lt;b: print(a,end='') a+=1else: print('end')0123456789end for语句for语句在python里是一个通用的序列迭代器：可以遍历任何有序的序列对象内的元素。可用于字符串、列表、元组、其他内置可迭代对象以及之后我们能通过类所创建的新对象。一般格式：1234for &lt;target&gt; in &lt;object&gt;: &lt;statements&gt;else: &lt;statements&gt; 在这里object需是可迭代的对象。每次从object里提取一个元素付给target，之后循环statements里的语句。例子1234&gt;&gt;&gt; for i in a: print (i,end='')12345 用法使用for循环时，其他开发语言会使用一个变量，定义起始，结束，递增值。但python里只能做迭代。这个时候可以使用range函数来代替。range函数格式：range([起始值,]结束值,[递增值])在这里，起始值默认是0，递增值默认为1。12345&gt;&gt;&gt; a=range(10)&gt;&gt;&gt; for i in a: print(i,end='')0123456789 当迭代后的元素为固定长度的元组。列表的时候：123456&gt;&gt;&gt; for a,b,c in [(1,2,3),(4,5,6),(7,8,9)]: print (a,b,c)1 2 34 5 67 8 9 嵌套循环（不一定是固定长度）：12345678&gt;&gt;&gt; for l in [(1,2,3),(4,5,6),(7,8,9)]: for i in l: print(i,end='') print()123456789 迭代器和解析文件迭代器文件访问方式如下： &lt;’file’&gt;.read():一次性读取全部内容。 &lt;’file’&gt;.readline():一次读取一行。 &lt;’file’&gt;.readlines():生成列表，每一行是每个元素。 &lt;’file’&gt;.next():跟readline()差不多，但读取完之后报错。 __next__()报错为stoplteration。在python中任何这类对象都认为是可迭代的。在python里迭代工具（比如for）会调用__next__()来获取数据，并以stoplteration来确认何时离开。 尽量不要使用readlines()函数，因为这个会一次性得把所有内容读取到内存里（转换为列表），运行速度会比较慢。 手动迭代为了支持手动迭代代码，python支持next()函数，它会自动读取__next__()函数。next(X)等同于X.__next__()。123456789101112&gt;&gt;&gt; file=open(r'D:\ruanjian\1.txt')&gt;&gt;&gt; file.__next__()'hello,world'&gt;&gt;&gt; file.seek(0)0&gt;&gt;&gt; next(file)'hello,world'&gt;&gt;&gt; next(file)Traceback (most recent call last): File "&lt;pyshell#135&gt;", line 1, in &lt;module&gt; next(file)StopIteration 这个会从第一行开始读取内容，但是这个文本文件就一行，所以读完之后再读会报错。迭代协议里，当时用for函数进行迭代时，会传递给iter()内置函数，以便可迭代对象中获取迭代器。返回的对象中有next()方法12345678910111213&gt;&gt;&gt; li=[1,2,3]&gt;&gt;&gt; i=iter(li)&gt;&gt;&gt; next(i)1&gt;&gt;&gt; next(i)2&gt;&gt;&gt; next(i)3&gt;&gt;&gt; next(i)Traceback (most recent call last): File "&lt;pyshell#141&gt;", line 1, in &lt;module&gt; next(i)StopIteration 对于文件来说，不需要转换成iter类型的这一步，因为文件对象就是自己的迭代器。123&gt;&gt;&gt; file=open(r'D:\ruanjian\1.txt')&gt;&gt;&gt; file is iter(file)True 但列表，元组，字符串就不是了。1234567&gt;&gt;&gt; s='123';l=[1,2,3];t=(1,2,3)&gt;&gt;&gt; s is iter(s)False&gt;&gt;&gt; l is iter(l)False&gt;&gt;&gt; t is iter(t)False 如果要使用next方法就需要先将字符串，列表，元组转换成迭代器 其他内置类型迭代器除了文件以及像列表这样的实际的序列外，其他类型也有其适用的迭代器。例如，遍历字典键的经典方法是明确的获取其键的列表。1234567&gt;&gt;&gt; dic=&#123;'a':1,'b':2,'c':3&#125;&gt;&gt;&gt; for key in dic.keys(): print(key,dic[key]) a 1b 2c 3 这个迭代器也可以直接对字典进行迭代：1234567&gt;&gt;&gt; iter1=iter(dic)&gt;&gt;&gt; iter1.__next__()'a'&gt;&gt;&gt; next(iter1)'b'&gt;&gt;&gt; next(iter1)'c' 列表解析遍历列表时，使用for循环来修饰它:123456&gt;&gt;&gt; li=[1,2,3,4,5]&gt;&gt;&gt; for i in range(len(li)): li[i]+=10&gt;&gt;&gt; li[11, 12, 13, 14, 15] 但这样看来并不简便，我们可以使用产生所需列表的一个单个表达式来完成上面的循环1234&gt;&gt;&gt; li=[1,2,3,4,5]&gt;&gt;&gt; li=[i+10 for i in li ]&gt;&gt;&gt; li[11, 12, 13, 14, 15] 这个先是运算[i+10 for i in li]之后，再把此值赋给li,具体的运算是先是对li进行迭代，每次把单个值赋给i，在进行i+10,成为新列表的单个元素。 扩展用法我们可以使用如下方法，将列表的某一项排除1234&gt;&gt;&gt; li=[1,2,3,4,5]&gt;&gt;&gt; li=[i+10 for i in li if i != 3]&gt;&gt;&gt; li[11, 12, 14, 15] 也可以在列表中进行循环嵌套,可以看到y的循环嵌套在了x循环里12&gt;&gt;&gt; [x+y for x in [1,2,3] for y in [10,20,30]][11, 21, 31, 12, 22, 32, 13, 23, 33] 其他迭代环境map也可用在迭代12&gt;&gt;&gt; list(map(str.upper,open(r'D:\ruanjian\1.txt')))['HELLO,WORLD'] map函数是把后面的可迭代的每个值当做前面的参数传入。上面的语句可以如下解释：123456&gt;&gt;&gt; tmp=[]&gt;&gt;&gt; for line in open(r'D:\ruanjian\1.txt'): tmp.append(str.upper(line)) &gt;&gt;&gt; tmp['HELLO,WORLD'] 相应的也有sorted会对迭代对象进行排序后生成列表12&gt;&gt;&gt; sorted(open(r'D:\ruanjian\1.txt'))['hello,world'] numerate也会对迭代对象进行运算后生成可迭代列表。enumerate就是在原有的顺序中添加序列号。12&gt;&gt;&gt; list(enumerate(open(r'D:\ruanjian\1.txt')))[(0, 'hello,world')] sum、any、all、max、min也可使用迭代器。1234&gt;&gt;&gt; max([3,5,1,6,4]),min([3,6,8,2,4])(6, 2)&gt;&gt;&gt; any([1,[],'True']),all([1,[],'True'])(True, False) python3中新的可迭代对象在python3中函数生成的是可迭代的特定对象：1234&gt;&gt;&gt; range(5)range(0, 5)&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] python3的这种方式会延迟计算，在提取内容的时候计算结果，这样会节省内存空间，不需要提前计算后放进内存，迭代对象迭代完成后不能再次读取12345678910111213141516&gt;&gt;&gt; def printlist(list1): for i in list1: print('function print:&#123;&#125;'.format(i)) yield 'Result: &#123;&#125;'.format(i)&gt;&gt;&gt; li=[1,2,3,4,5]&gt;&gt;&gt; s=printlist(li)&gt;&gt;&gt; s.__next__()function print:1'Result: 1'&gt;&gt;&gt; s.__next__()function print:2'Result: 2'&gt;&gt;&gt; s.__next__()function print:3'Result: 3']]></content>
      <tags>
        <tag>python语句与语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据类型之数字和字符串]]></title>
    <url>%2F2018%2F12%2F13%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[python数据类型： Number（数字） String(字符串) List(列表) Dictonary（字典） Tuple(元组) sets(集合) 其中数字、字符串、元组是不可变的，列表、字典是可变的。对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象（如果没有其他变量引用原有对象的话（即引用计数为0），原有对象就会被回收）。 数字 int:整数 &amp;ensp;&amp;ensp; 1.正负数 &amp;ensp; &amp;ensp;2.十六进制(表示方式为0x或者0X开头。例如：0xff) &amp;ensp; &amp;ensp;3.八进制(表示方式为0o或者0O开头。例如：0o632457) &amp;ensp;&amp;ensp; 4.二进制 (表示方式为0b或者0B开头。例如：0b101100) fraction:分数 float:浮点数 complex:复数 bool:布尔型(特殊的数值类型，只有True和False两个值)进制转换整数转其他进制使用bin(i),oct(i),hex(i)函数可以将十进制数分别转换为二进制，八进制，十六进制1234567&gt;&gt;&gt; s=10&gt;&gt;&gt; bin(s)'0b1010'&gt;&gt;&gt; oct(s)'0o12'&gt;&gt;&gt; hex(s)'0xa' 使用int(str,base)可以将非十进制的数转换成整数，其中str是文本形式的数字，base可以为2,8,16数字，分别代表二进制，八进制，十六进制，最高到36位，最低为212345678910 &gt;&gt;&gt; int('0b10010',2)18&gt;&gt;&gt; int('0o52415',8)21773&gt;&gt;&gt; int('0x134ab',16)79019&gt;&gt;&gt; int('s',32)28&gt;&gt;&gt; int('yz',36)1259 当然也可以进行16进制转二进制八进制，八进制可以转其他进制123456789101112&gt;&gt;&gt; hex(0b1001)'0x9'&gt;&gt;&gt; hex(0o1234)'0x29c'&gt;&gt;&gt; oct(0b101)'0o5'&gt;&gt;&gt; oct(0xff)'0o377'&gt;&gt;&gt; bin(0xff)'0b11111111'&gt;&gt;&gt; bin(0o7777)'0b111111111111' 各类运算符 算数运算符：+,-,*,/,%.//,** 比较运算符：==，!=,&gt;,&lt;,&lt;=,&gt;= 赋值运算符：=,+=,-=,*=,/=,%=,//=.**= 位运算符：&amp;,|,^,~,&lt;&lt;,&gt;&gt; 逻辑运算符：and,or,not 成员运算符：in,not in 身份运算符：is,is not12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=12&gt;&gt;&gt; f=~a&gt;&gt;&gt; f-13&gt;&gt;&gt; bin(f)'-0b1101'&gt;&gt;&gt; bin(a)'0b1100'&gt;&gt;&gt; bin(a&lt;&lt;1)'0b11000'&gt;&gt;&gt; bin(a&gt;&gt;1)'0b110'&gt;&gt;&gt; list=[1,2,3,4,5]&gt;&gt;&gt; a=3&gt;&gt;&gt; print (a in list)True&gt;&gt;&gt; print (a not in list)False&gt;&gt;&gt; a=['1,2,3,4,5']&gt;&gt;&gt; b=a&gt;&gt;&gt; print (b is a )True&gt;&gt;&gt; print (b is not a )False&gt;&gt;&gt; b=a[:]&gt;&gt;&gt; print (b is a) #这是因为字符串是不可变的False&gt;&gt;&gt; print (id(a))42473480&gt;&gt;&gt; print (id(b))42485000 运算符优先级 ** （优先级最高的是幂运算） ~,+,- (加和减都是一元运算符) *，/，%，// +,- &lt;&lt;,&gt;&gt; &amp; ^,| &lt;=,&gt;=,&lt;,&gt; ==,!= =,+=,-=,*=,/=,%=,//=,**=数学函数的应用 power：幂函数，功能与运算符**一样 12&gt;&gt;&gt; pow(2,3)8 sqrt：取当前数的平方根 123&gt;&gt;&gt; import math&gt;&gt;&gt; math.sqrt(4)2.0 max：最大值 12&gt;&gt;&gt;max(2,3,4,5,1,9,6)9 min：最小值 12&gt;&gt;&gt; min(2,3,4,5,1,9,6)1 abs与fabs：取绝对值，fabs取出的是浮点数 1234&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; math.fabs(-1)1.0 round：四舍五入（当小数为5的时候会向靠近偶数的一端进） 12345678&gt;&gt;&gt; round(3.5)4&gt;&gt;&gt; round(2.5)2&gt;&gt;&gt; round(2.54)3&gt;&gt;&gt; round(2.45)2 ceil：向上取整 1234&gt;&gt;&gt; math.ceil(1.7)2&gt;&gt;&gt; math.ceil(1.3)2 floor：向下取整 1234&gt;&gt;&gt; math.floor(1.7)1&gt;&gt;&gt; math.floor(1.3)1 cmp：python2中的比较函数，当前面数值大返回-1，一样大返回0，后面数值大返回1 123456&gt;&gt;&gt; cmp(1,2)-1&gt;&gt;&gt; cmp(1,1)0&gt;&gt;&gt; cmp(2,1)1 随机数函数&ensp;&ensp;- 取0-1之间的随机小数： 123&gt;&gt;&gt; import random&gt;&gt;&gt; random.random()0.18001643527271916 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 取自定义数里的随机数：(可以取多个元素)12345678&gt;&gt;&gt; random.choice([1,2,3,4,5])2&gt;&gt;&gt; random.choice([1,2,3,4,5])3&gt;&gt;&gt; random.sample([1,2,3,4,5,6,7,8,9],2)[3, 7]&gt;&gt;&gt; random.sample([1,2,3,4,5,6,7,8,9],3)[4, 9, 3] &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 随机打乱顺序：1234&gt;&gt;&gt; a=[1,2,3,4,5,8]&gt;&gt;&gt; random.shuffle(a)&gt;&gt;&gt; a[1, 8, 2, 3, 4, 5] &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 获取N位随机数：(二进制)123456&gt;&gt;&gt; random.getrandbits(6)55&gt;&gt;&gt; random.getrandbits(6)48&gt;&gt;&gt; random.getrandbits(7)104 modf：把浮点数的整数位和小数位单独取出来 12345678&gt;&gt;&gt; math.modf(1.4)(0.3999999999999999, 1.0)&gt;&gt;&gt; math.modf(1.5)(0.5, 1.0)&gt;&gt;&gt; math.modf(2.8)(0.7999999999999998, 2.0)&gt;&gt;&gt; math.modf(3.1)(0.10000000000000009, 3.0) log：指数函数。默认e为底数，结果为浮点数。也可以自定义底数 12345678&gt;&gt;&gt; math.log(4,2)2.0&gt;&gt;&gt; math.log2(4)2.0&gt;&gt;&gt; math.log10(100)2.0&gt;&gt;&gt; math.log(100,10)2.0 格式化输出：格式化输出保留有效数字,格式化输出的是字符串 12345678&gt;&gt;&gt; s=format(2.345,'0.2f')&gt;&gt;&gt; s&gt;&gt;&gt; type (s)&lt;class 'str'&gt;&gt;&gt;&gt; round(2.5)2&gt;&gt;&gt; format(2.5,'0.0f')'2' Decimal模块：在使用浮点数的时候，因为计算机是使用二进制表示，所以会出现精度问题，可以使用Deciamal模块来解决精度问题 123456789&gt;&gt;&gt; a=4.2&gt;&gt;&gt; b=2.1&gt;&gt;&gt; a+b6.300000000000001&gt;&gt;&gt; from decimal import Decimal&gt;&gt;&gt; a=Decimal('2.1')&gt;&gt;&gt; b=Decimal('4.2')&gt;&gt;&gt; a+bDecimal('6.3') 格式化输出——format：使用format进行进制转换 12345678910111213&gt;&gt;&gt; a=20&gt;&gt;&gt; bin(a)'0b10100'&gt;&gt;&gt; oct(a)'0o24'&gt;&gt;&gt; hex(a)'0x14'&gt;&gt;&gt; format(a,'b')'10100'&gt;&gt;&gt; format(a,'o')'24'&gt;&gt;&gt; format(a,'x')'14' 字符串字符串(python2默认使用ascii编码，使用Unicode编码须在字符串前加u,python3使用unicode编码）a=’str’a=u’str’ 字符串表示方法 单引号：’str’ ‘1’ 双引号：”str””1” 三引号：’’’…str…’’’ “””…str…””” 转义字符：“str1 \tadded tab\nstr2” Raw字符串：r”C:\user\administrator”(无法进行转义操作)字符串操作字符串合并12345678910 &gt;&gt;&gt; 'abc'+'def''abcdef'&gt;&gt;&gt; 'hello' *5'hellohellohellohellohello'&gt;&gt;&gt; print ('-'*50)--------------------------------------------------&gt;&gt;&gt; "aa""bb"'aabb'&gt;&gt;&gt; 'ab''cd''abcd' 字符串取值1234567891011121314151617181920212223242526a="text"&gt;&gt;&gt; for c in a:... print (c,end='')...text&gt;&gt;&gt; for c in a:... print (c,end='-')...t-e-x-t-&gt;&gt;&gt; 'x' in aTrue&gt;&gt;&gt; text='this_is_str'&gt;&gt;&gt; text[0:4]'this'&gt;&gt;&gt; text[5:7]'is'&gt;&gt;&gt; text[:4]'this'&gt;&gt;&gt; text[-3:]'str'&gt;&gt;&gt; text[-12:-7]'this'&gt;&gt;&gt; text[::2]'ti_ssr'&gt;&gt;&gt; text[8:1:-2]'ss_i' 字符串编码转换12345678&gt;&gt;&gt; ord(&apos;d&apos;)100&gt;&gt;&gt; chr(99)&apos;c&apos;&gt;&gt;&gt; ord(&apos;王&apos;)29579&gt;&gt;&gt; chr(29579)&apos;王&apos; 字符串大小写转换 这里利用ascii编码进行大小写转换 1234567891011121314151617181920&gt;&gt;&gt; Text=&quot;&quot; #初始化Text&gt;&gt;&gt; text=&quot;aSdFgHjK&quot; &gt;&gt;&gt; for i in text:... i_code=ord(i)... if 97&lt;=i_code and i_code&lt;=122:... Text+=chr(i_code-32)... else:... Text+=i...&gt;&gt;&gt; Text&apos;ASDFGHJK&apos;&gt;&gt;&gt; for x in text:... x_code=ord(x)... if 65&lt;=x_code and x_code&lt;=90:... Text+=chr(x_code+32)... else:... Text+=x...&gt;&gt;&gt; Text&apos;ASDFGHJKasdfghjk&apos; 这里利用字符串的方法进行转换 123&gt;&gt;&gt; str=&apos;asdFGHzxcVBN&apos;&gt;&gt;&gt; str.replace(&apos;asd&apos;,&apos;ASD&apos;)&apos;ASDFGHzxcVBN&apos; 除此之外，还可以使用字符串的大小写方法进行大小写转换 ascii编码对照表二进制 | 十进制 |十六进制 |图形|—|—|—|—|0010 0000|32|20|（空格）0010 0001|33|21|!0010 0010|34|22|”0010 0011|35|23|#0010 0100|36|24|$0010 0101|37|25|%0010 0110|38|26|&amp;0010 0111|39|27|’’0010 1000|40|28|(0010 1001|41|29|)0010 1010|42|2A|*0010 1011|43|2B|+0010 1100|44|2C|,0010 1101|45|2D|-0010 1110|46|2E|.0010 1111|47|2F|/0011 0000|48|30|00011 0001|49|31|10011 0010|50|32|20011 0011|51|33|30011 0100|52|34|40011 0101|53|35|50011 0110|54|36|60011 0111|55|37|70011 1000|56|38|80011 1001|57|39|90011 1010|58|3A|:0011 1011|59|3B|;0011 1100|60|3C|&lt;0011 1101|61|3D|=0011 1110|62|3E|&gt;0011 1111|63|3F|?0100 0000|64|40|@0100 0001|65|41|A0100 0010|66|42|B0100 0011|67|43|C0100 0100|68|44|D0100 0101|69|45|E0100 0110|70|46|F0100 0111|71|47|G0100 1000|72|48|H0100 1001|73|49|I0100 1010|74|4A|J0100 1011|75|4B|K0100 1100|76|4C|L0100 1101|77|4D|M0100 1110|78|4E|N0100 1111|79|4F|O0101 0000|80|50|P0101 0001|81|51|Q0101 0010|82|52|R0101 0011|83|53|S0101 0100|84|54|T0101 0101|85|55|U0101 0110|86|56|V0101 0111|87|57|W0101 1000|88|58|X0101 1001|89|59|Y0101 1010|90|5A|Z0101 1011|91|5B|[0101 1100|92|5C|\0101 1101|93|5D|]0101 1110|94|5E|^0101 1111|95|5F|_0110 0000|96|60|`0110 0001|97|61|a0110 0010|98|62|b0110 0011|99|63|c0110 0100|100|64|d0110 0101|101|65|e0110 0110|102|66|f0110 0111|103|67|g0110 1000|104|68|h0110 1001|105|69|i0110 1010|106|6A|j0110 1011|107|6B|k0110 1100|108|6C|l0110 1101|109|6D|m0110 1110|110|6E|n0110 1111|111|6F|o0111 0000|112|70|p0111 0001|113|71|q0111 0010|114|72|r0111 0011|115|73|s0111 0100|116|74|t0111 0101|117|75|u0111 0110|118|76|v0111 0111|119|77|w0111 1000|120|78|x0111 1001|121|79|y0111 1010|122|7A|z0111 1011|123|7B|{0111 1100|124|7C||0111 1101|125|7D|}0111 1110|126|7E|~ 字符串方法字符串大小写相关的方法 capitalize()：字符串首字母大写 123&gt;&gt;&gt; str='hello world'&gt;&gt;&gt; str.capitalize()'Hello world' title()：字符串中单词的首字母大写 12&gt;&gt;&gt; str.title()'Hello World' upper()：字符串转换成大写 1234567&gt;&gt;&gt; str.upper()'HELLO WORLD'``` - lower()：字符串转换成小写```python&gt;&gt;&gt; str.lower()'hello world' swapcase()：字符串大小写互转 123&gt;&gt;&gt; str='HellO wORld'&gt;&gt;&gt; str.swapcase()'hELLo WorLD' 字符串排版相关的方法 center()：居中对齐 12345&gt;&gt;&gt; str='hello'&gt;&gt;&gt; str.center(11)' helloo '&gt;&gt;&gt; str.center(11,'_')'___helloo__' ljust()：居左对齐 1234&gt;&gt;&gt; str.ljust(11,'_')'helloo_____'&gt;&gt;&gt; str.ljust(11)'helloo rjust()：居右对齐 1234&gt;&gt;&gt; str.rjust(11)' hello'&gt;&gt;&gt; str.rjust(11,'_')'_____hello' expandtabs()：修改tab空格的个数 1234567 &gt;&gt;&gt; str='hello\tworld'&gt;&gt;&gt; print (str)hello world&gt;&gt;&gt; str.expandtabs(9)'hello world'&gt;&gt;&gt; str.expandtabs(4)'hello world' zfill()：将字符串扩充到指定长度，前面使用0填充 1234 &gt;&gt;&gt; str.zfill(20)'000000000hello\tworld' &gt;&gt;&gt; 'sad'.zfill(10)'0000000sad' strip()：删除字符串两边(左边lstrip或右边rstrip)的指定字符（默认为空格和换行符） 123456789101112 &gt;&gt;&gt; str=' hello world '&gt;&gt;&gt; str.strip()'hello world'&gt;&gt;&gt; str.lstrip()'hello world '&gt;&gt;&gt; str.rstrip()' hello world'&gt;&gt;&gt; str='hello,world'&gt;&gt;&gt; str.strip('h')'ello,world'&gt;&gt;&gt; str.strip('[held]')'o,wor' 字符串查找相关的方法 startswith(prefix[,start[,end]])/endswith(suffix[,start[,end]]) 判断是否以特定字符串开头或者结尾123456789101112131415161718192021&gt;&gt;&gt; str='hello,world'&gt;&gt;&gt; str.startswith('hello')True&gt;&gt;&gt; str.startswith('hello',0,5)True&gt;&gt;&gt; str.startswith('hello',1,5)False&gt;&gt;&gt; str.endswith('rld',8)True&gt;&gt;&gt; str.endswith('rld',9)False&gt;&gt;&gt; str.endswith('rld',8,11)True``` - count(sub[,start[,end]])：相应字符串在文本中的个数```python&gt;&gt;&gt; str='hello,world'&gt;&gt;&gt; str.count('l')3&gt;&gt;&gt; str.count('ll')1 find/rfind()：分别从字符串前后开始查找第一个匹配到的字符串的位置,找不到就返回-1 12345str='hello,world'&gt;&gt;&gt; str.find('l')2&gt;&gt;&gt; str.rfind('l')9 index/rindex()：与find方法类似，但是找不到会报错 123456789&gt;&gt;&gt; str.index('l')2&gt;&gt;&gt; str.rindex('l')9&gt;&gt;&gt; str.index('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; str.find('a') replace(old,new[,count])：替换字符串，count代表替换个数 1234&gt;&gt;&gt; str.replace('l','L')'heLLo,worLd'&gt;&gt;&gt; str.replace('l','L',1)'heLlo,world' 格式判断相关方法 isalpha() ：判断是否是字母 isdigit()：判断是否是数字 isalnum()：判断是否是数字和字母 islower()：判断是否有字母，且字母为小写字母 isupper()：判断是否有字幕，且字母为大写字母 isspace()：判断是不是只有空格和换行符号 istitle()：判断字符串每个单词的首字母是否大写 isdecimal()：判断是不是数字 isnumeric()：判断是不是数字 isidentifier()：判断字符能否成为标识符 isprintable()：判断字符是否全部能打印的 isdigit、isdecimal、isnumeric三者的区别isdigit()True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字Error: 无 isdecimal()True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字Error: byte数字（单字节） isnumeric()True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节） 字符串分隔 split([sep[,maxsplit]])/rsplit([sep[,maxsplit]])：分别从左右按照sep字符串分隔，最多分隔maxsplit此，默认无数次 12345&gt;&gt;&gt; str=&apos;asd,fgh,jkl&apos;&gt;&gt;&gt; str.split(&apos;,&apos;)[&apos;asd&apos;, &apos;fgh&apos;, &apos;jkl&apos;]&gt;&gt;&gt; str.rsplit(&apos;,&apos;,1)[&apos;asd,fgh&apos;, &apos;jkl&apos;] splitlines()以\n或者\r或者\n\r分隔 123&gt;&gt;&gt; str='asd\nfgh\njkl'&gt;&gt;&gt; str.splitlines()['asd', 'fgh', 'jkl'] partition(sep)：将分隔符也作为一个元素列出来 12&gt;&gt;&gt; 'http://www.baidu.com'.partition('://')('http', '://', 'www.baidu.com') 字符串其他方法 join()：以特定的分隔符将字符串分隔123&gt;&gt;&gt; str='asdfg'&gt;&gt;&gt; '-'.join(str)'a-s-d-f-g' 字符串格式化输出python字符串格式化输出的三种方式 使用字符串格式格式化操作符——百分号% 使用字符串方法 format 使用 f-strings进行字符串格式化使用%进行格式化这种格式化表达式类似于C语言 格式化操作符（%） 说明 s 获取传入对象的str方法的返回值，并将其格式化到指定位置 r 与s一样，但输出方式是repr方式，而不是str c 整数：将数字转换成其unicode对应的值，10进制范围为 0&lt;=i&lt;=1114111（py27则只支持0-255）；字符：将字符添加到指定位置 d 有符号十进制（整数），将整数、浮点数转换成十 进制表示，并将其格式化到指定位置 i 有符号整数 u 无符号整数 o 将整数转换成八 进制表示，并将其格式化到指定位置 x 将整数转换成十六进制表示，并将其格式化到指定位置 X 与x一样，A-F是大写 e 浮点指数，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e） E 与e一样，E为大写 f 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位） F 浮点数十进制 g 浮点e或f，自动调整将整数、浮点数转换成 浮点型或科学计数法表示 G 浮点E或F，自动调整将整数、浮点数转换成 浮点型或科学计数法表示 % 当字符串中存在格式化标志时，需要用 %%表示一个百分号 注：Python中百分号格式化是不存在自动将整数转换成二进制表示的方式 举例123456789101112&gt;&gt;&gt; "%s|%r|%c" %("this is str","this is repr","C")"this is str|'this is repr'|C"&gt;&gt;&gt; "%d|%i|%o|%x|%X|" %(3,5,12,13,14)'3|5|14|d|E|'&gt;&gt;&gt; "%e|%E|%f|%F|%g|%G" %(1.5E3,1.5e3,13.5,13.5,1.5e13,13.5E15)'1.500000e+03|1.500000E+03|13.500000|13.500000|1.5e+13|1.35E+16'&gt;&gt;&gt; "%(string)-10s"%(&#123;'string':'1'&#125;)'1 &gt;&gt;&gt; "%(float)+10.2F"%(&#123;'float':3.1&#125;)' +3.10'&gt;&gt;&gt; "%(float)-10.2f"%(&#123;'float':3.1&#125;)'3.10 ' 使用format方法语法：{}.format(value)参数:（value):可以是整数，浮点数，字符串，字符甚至变量。Returntype：返回一个格式化字符串，其值在占位符位置作为参数传递。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#位置参数&gt;&gt;&gt; username='wanger'&gt;&gt;&gt; password=123456&gt;&gt;&gt; print ("&#123;&#125;'s password is &#123;&#125;".format(username,password))wanger's password is 123456 &gt;&gt;&gt; username='wanger'&gt;&gt;&gt; password=123456&gt;&gt;&gt; print ("&#123;1&#125;'s password is &#123;0&#125;".format(password,username))wanger's password is 123456 #下标参数&gt;&gt;&gt; si=['KB','MB','GB','TB','PB','EB','ZB','YB']&gt;&gt;&gt; '1000&#123;0[0]&#125;=1&#123;0[1]&#125;'.format(si)'1000KB=1MB'#浮点数精度&gt;&gt;&gt; '&#123;:.4f&#125;'.format(3.1415926)'3.1416'&gt;&gt;&gt; '&#123;:&gt;10.4f&#125;'.format(3.1415926)' 3.1416'&gt;&gt;&gt; 'this is a test &#123;t[0]&#125;'.format(t='hello')'this is a test h'&gt;&gt;&gt; 'this is a test &#123;t[1]&#125;'.format(t='hello')'this is a test e'#使用模块作为参数&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.platform'win32'&gt;&gt;&gt; "&#123;0.platform&#125;".format(sys)'win32'&gt;&gt;&gt; 'my laptop platform is &#123;s&#125;'.format(s=sys.platform)'my laptop platform is win32'&gt;&gt;&gt; 'my laptop platform is (s.platform)'.format(s=sys)'my laptop platform is (s.platform)'#关键字参数&gt;&gt;&gt; 'my name is &#123;name&#125; ,age is &#123;age&#125;'.format(name='wanger',age='25')'my name is wanger ,age is 25``` 当占位符&#123;&#125;为空时，Python将按顺序替换通过str.format（）传递的值。 str.format（）方法中存在的值本质上是元组数据类型，元组中包含的每个单独值都可以通过索引号调用，索引号以索引号0开头。 第三段代码的变量si是一个列表，&#123;0&#125;就代表format()方法的第一个参数，那么&#123;0[0]&#125;就代表列表的第一个元素，&#123;0[1]&#125;就代表列表的第二个元素 这个例子说明格式说明符可以通过利用（类似） Python 的语法访问到对象的元素或属性。这就叫做复合字段名 (compound field names) 。 以下复合字段名都是“ 有效的 ” 。 • 使用列表作为参数，并且通过下标索引来访问其元素（跟上一例类似） • 使用字典作为参数，并且通过键来访问其值 • 使用模块作为参数，并且通过名字来访问其变量及函数 • 使用类的实例作为参数，并且通过名字来访问其方法和属性 • 以上方法的任意组合 ###### format_spec参数表达式：format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]- fill ::= &lt;'any character'&gt;- align ::= "&lt;"'左对齐' | "&gt;"‘右对齐’ | "="‘在数字里，符号左对齐，数字右对齐 | "^"‘居中’- sign ::= "+" | "-" | " "（当sign=’+‘时，即使是正数也会显示符号，-只有为负数的时候才显示负号，为空格时，会在正数前面留下符号位）- width ::= integer (定义输出的宽度)fill和align以及后面的width相当于str方法中的center，ljust,rjust ```python&gt;&gt;&gt; '&#123;:+^15&#125;'.format('start')'+++++start+++++'&gt;&gt;&gt; '&#123;:+^15&#125;'.format('end')'++++++end++++++'&gt;&gt;&gt; '&#123;:*&lt;15&#125;'.format('end')'end************'&gt;&gt;&gt; '&#123;:*&gt;15&#125;'.format('start')'**********start'&gt;&gt;&gt; '&#123;:=+20&#125;'.format(10)'+ 10'&gt;&gt;&gt; print("&#123;:=10&#125;\n&#123;:=+20&#125;\n&#123;:-^10&#125;\n&#123;:=-13&#125;".format(10,10,'-',-15)) 10+ 10----------- 15 #只有在数字显示里，显示二进制数，八进制数，十六进制数的时候，需要显示前面的0b,0o,0x的时候才会用到 123456&gt;&gt;&gt; "&#123;0:8b&#125;,&#123;0:8o&#125;,&#123;0:8x&#125;".format(10)' 1010, 12, a'&gt;&gt;&gt; "&#123;0:b&#125;,&#123;0:o&#125;,&#123;0:x&#125;".format(10)'1010,12,a'&gt;&gt;&gt; ("&#123;0:#8b&#125;,&#123;0:#8o&#125;,&#123;0:#8x&#125;".format(10))' 0b1010, 0o12, 0xa' ,符号是表示数字时每三位中间加， 12&gt;&gt;&gt; '&#123;:,&#125;'.format(100000000000)'100,000,000,000' 0是固定宽度前面补0 .precision ::= integer(精度显示) 12&gt;&gt;&gt; &apos;&#123;:010.5&#125;&apos;.format(3.1415926)&apos;00003.1416&apos; type ::= “b” | “c” | “d” | “e” | “E” | “f” | “F” | “g” | “G” | “n” | “o” | “s” | “x” | “X” | “%” (跟之前使用%表示的相等)&ensp;&ensp;- 当为字符时：使用s，默认就是s&ensp;&ensp;- 当为整数时：b,o,x和X是二进制、八进制、十六进制，c是数字按Unicode转换成字符，d是正常十进制，默认就是d。也可以使用n来代替d 12&gt;&gt;&gt; "&#123;0:d&#125;,&#123;0:b&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;".format(10)'10,1010,12,a,A' &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;- 为浮点数时：e和E是指数，f和F是浮点数。g和G是同一的，也可以使用n来代替g, %是显示百分比12&gt;&gt;&gt; "&#123;0:e&#125;,&#123;0:F&#125;,&#123;0:g&#125;,&#123;0:n&#125;,&#123;0:%&#125;".format(10.3)'1.030000e+01,10.300000,10.3,10.3,1030.000000%' 使用f-strings方法进行格式化f-strings也称为“格式化字符串文字”，f字符串是f在开头有一个字符串文字，其中以 {} 包含的表达式会进行值替换。表达式在运行时进行评估，然后使用format协议进行格式化。其中以 {} 包含的表达式会进行值替换。 特点 代码简洁，没有多余的引号 括号{}里面的变量，可以是字符串类型，也可以是整型、浮点型，或者是复杂类型，比如数组、词典等，会自动转换成成字符串形式。 括号{}里面还可以是函数，比如 f’数组a的长度为:{len(a)}’。一句话，只要是位于 {} 中的，都会当做 python 代码来执行。但里面只能写表达式，不能写执行语句如{a=2}之类的。 f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式，速度非常快 简单举例1234567&gt;&gt;&gt; name=&apos;wanger&apos;&gt;&gt;&gt; age=25&gt;&gt;&gt; f&quot;hello,I&apos;m &#123;name&#125;,my age &#123;age&#125; &quot;&quot;hello,I&apos;m wanger,my age 25 &quot;#也可以使用大写F&gt;&gt;&gt; F&quot;hello, I&apos;m &#123;name&#125;,my age &#123;age&#125; &quot;&quot;hello, I&apos;m wanger,my age 25 &quot; 当然也可以进行简单的计算12&gt;&gt;&gt; f&quot;&#123;2*3&#125;&quot;&apos;6&apos; 也可以调用函数123456&gt;&gt;&gt; def test(input):... return input.lower()...&gt;&gt;&gt; name=&apos;WangEr&apos;&gt;&gt;&gt; f&quot;&#123;test(name)&#125; is funny&quot;&apos;wanger is funny&apos; 还可以选择直接调用方法123&gt;&gt;&gt; name='WangEr'&gt;&gt;&gt; f"&#123;name.lower()&#125; is funny"'wanger is funny' 在使用字典的时候。如果要为字典的键使用单引号，请记住确保对包含键的f字符串使用双引号。123comedian = &#123;&apos;name&apos;: &apos;wanger&apos;, &apos;age&apos;: 25&#125;f&quot;The comedian is &#123;comedian[&apos;name&apos;]&#125;, aged &#123;comedian[&apos;age&apos;]&#125;.&quot;&apos;The comedian is wanger, aged 25.&apos; 使用字符串的场景 使用多个界定符分隔字符串split只能使用单一字符串，如果要使用多个分隔符的话，就要用到正则表达式模块了1234&gt;&gt;&gt; str=&apos;asd,dfg;zxc ert uio&apos;&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r&apos;[;,\s]\s*&apos;,str)[&apos;asd&apos;, &apos;dfg&apos;, &apos;zxc&apos;, &apos;ert&apos;, &apos;uio&apos;] []表示里面字符任意匹配。[;, ]表示；或者，或者空格，\s*表示任意个前面字符 字符串开头或结尾匹配比如要看一个地址是否是http://或者ftp://开头或者查看文件后缀是不是TXT格式可以这样查看 1234567891011&gt;&gt;&gt; url='http://www.baidu.com'&gt;&gt;&gt; ftp='ftp://www.baidu.com'&gt;&gt;&gt; url.startswith(('http://','ftp://'))True&gt;&gt;&gt; txt='ziyuan.txt'&gt;&gt;&gt; txt.endswith('txt')True&gt;&gt;&gt; url[0:7]=="http://" or url[0:6]=="ftp://"True&gt;&gt;&gt; txt[7:10]=="txt"True 用shell通配符我们还可以使用shell通配符来检查文件的结尾，这需要用到fnmatch模块fnmatch不区分大小写，fnmatchcase是区分大小写的 123456789&gt;&gt;&gt; from fnmatch import fnmatch,fnmatchcase&gt;&gt;&gt; fnmatch('log.txt','*.txt')True&gt;&gt;&gt; fnmatch('log.TXT','*.txt')True&gt;&gt;&gt; fnmatchcase('log.TXT','*.txt')False&gt;&gt;&gt; fnmatchcase('log.TXT','*.TXT')True 匹配和搜索特定格式的文本普通匹配可以使用find方法，如果是特定格式的话还是会用到正则模块 1234567891011121314&gt;&gt;&gt; date1='2018/10/24'&gt;&gt;&gt; date2='2018/12/21'&gt;&gt;&gt; date3='2018-12-05'&gt;&gt;&gt; def isdate(date):... if re.match(r'\d+/\d+/\d+',date):... print ('match OK')... else:... print ('not match')&gt;&gt;&gt; isdate(date1)match OK&gt;&gt;&gt; isdate(date2)match OK&gt;&gt;&gt; isdate(date3)not match 在正则模块re中\d表示单个数字，+表示一个或多个前面的字段 搜索和替换特定的文本格式普通的匹配可以使用replace方法，如果匹配特定格式，还是要用正则模块re12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; date='today is 13/12/2018'&gt;&gt;&gt; re.sub(r'(\d+)/(\d+)/(\d+)',r'\3-\2-\1',date)'today is 2018-12-13'&gt;&gt;&gt; datepat=re.compile(r'(\d+)/(\d+)/(\d+)') #为了防止每次都要定义匹配模式，可以在这里定义一个匹配的变量，以后匹配直接调用这个变量&gt;&gt;&gt; datepat.sub(r'\3-\2-\1',date)'today is 2018-12-13'&gt;&gt;&gt; date='yestory is 12/12/2018,today is 13/12/2018'&gt;&gt;&gt; datepat.subn(r'\3-\2-\1',date)('yestory is 2018-12-12,today is 2018-12-13', 2) \1,\2,\3分别代表前面匹配模式中的第一个括号匹配到的，第二个括号匹配到的，第三个括号匹配到的，使用subn方法可以看到匹配到几次 忽略大小写的搜索替换如果要忽略大小写还是要用到re模块，需要用到的是re的IGNORECASE方法12345678&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('replace','Replace,replace,REPLACE')['replace']&gt;&gt;&gt; re.findall('replace','Replace,replace,REPLACE',flags=re.IGNORECASE)['Replace', 'replace', 'REPLACE']&gt;&gt;&gt; str='Replace is the same as REPLACE'&gt;&gt;&gt; re.sub('replace','WORD',str,flags=re.IGNORECASE)'WORD is the same as WORD' 最短匹配模式用正则表达式匹配某个文本模式，而他找到的是最长匹配，如果要匹配最短字符，可以用下面的方法 12345678910&gt;&gt;&gt; strpat=re.compile(r&apos;\&quot;(.*)\&quot;&apos;)&gt;&gt;&gt; text=&apos;this is my &quot;name&quot;&apos;&gt;&gt;&gt; strpat.findall(text)[&apos;name&apos;]&gt;&gt;&gt; text=&apos;this is my &quot;name&quot; and this is my &quot;age&quot;&apos;&gt;&gt;&gt; strpat.findall(text)[&apos;name&quot; and this is my &quot;age&apos;]&gt;&gt;&gt; strpat=re.compile(r&apos;\&quot;(.*?)&quot;&apos;)&gt;&gt;&gt; strpat.findall(text)[&apos;name&apos;, &apos;age&apos;] 删除字符串中不需要的字符去掉字符串开头，中间或者结尾不想要的字符串，比如空白 12345678910&gt;&gt;&gt; s='hello world \n'&gt;&gt;&gt; s.strip()'hello world'&gt;&gt;&gt; s.lstrip()'hello world \n'&gt;&gt;&gt; s.rstrip()'hello world'&gt;&gt;&gt; import re&gt;&gt;&gt; re.sub(r'\s+','',s)'helloworld' 合并拼接字符串 12345678910&gt;&gt;&gt; a=&apos;hello&apos;&gt;&gt;&gt; b=&apos;world&apos;&gt;&gt;&gt; a+&apos; &apos;+b&apos;hello world&apos;&gt;&gt;&gt; &apos;&#123;&#125; &#123;&#125;&apos;.format(a,b)&apos;hello world&apos;&gt;&gt;&gt; &apos; &apos;.join([a,b])&apos;hello world&apos;&gt;&gt;&gt; a=print(a,b)hello world]]></content>
      <tags>
        <tag>python数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-os模块学习笔记]]></title>
    <url>%2F2018%2F11%2F30%2Fpython-os%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[import osos.mkdir(name) #创建目录os.path.exists(name) #判断文件或者目录是否存在os.path.isdir(name) #判断指定对象是否为目录。是True,否则False。os.mknod(name) #创建一个文件os.path.isfile(name) #判断文件是否存在，存在返回True，否则返回False12345678&gt;&gt;&gt; os.mkdir('aaaa')&gt;&gt;&gt; os.path.exists('aaaa')True&gt;&gt;&gt; os.path.isdir('aaaa')True&gt;&gt;&gt; os.mknod('test.txt')&gt;&gt;&gt; os.path.isfile('test.txt')True os.rmdir(name) #删除一个目录os.remove(name) #删除一个文件123456&gt;&gt;&gt; os.rmdir('aaaa')&gt;&gt;&gt; os.path.isdir('aaaa')False&gt;&gt;&gt; os.remove('test.txt')&gt;&gt;&gt; os.path.isfile('test.txt')False os.getcwd() #获取当前路径，相当于Linux下的pwd命令os.path.abspath(file|dir) #获取文件或者目录的绝对路径os.path.basename(name) #获取文件名或文件夹名os.path.dirname(name) #获取文件或文件夹的路径12345678&gt;&gt;&gt; os.getcwd()'/root/SuXinProject'&gt;&gt;&gt; os.path.abspath('.')'/root/SuXinProject'&gt;&gt;&gt; os.path.dirname('/root/user.sh')'/root'&gt;&gt;&gt; os.path.basename('/root/user.sh')'user.sh' os.path.splitext #分离文件名与扩展名os.path.split #分离目录与文件名os.path.join(path,name) #连接目录与文件名或目录123456&gt;&gt;&gt; os.path.split('/root/user.sh')('/root', 'user.sh')&gt;&gt;&gt; os.path.splitext('/root/user.sh')('/root/user', '.sh')&gt;&gt;&gt; os.path.join('/root/','user.sh')'/root/user.sh' os.chdir(dir) #切换目录os.listdir(dir) #列出目录下的所有目录和文件os.path.getsize(file|dir) #获取文件的大小，如果是目录则直接返回0os.stat(name) #获取文件属性os.system(commond) #执行系统命令os.rename(old,new) #文件重命名1234567891011&gt;&gt;&gt; os.chdir('/root')&gt;&gt;&gt; os.listdir('.')['.vnc', 'mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz', '.pydistutils.cfg', '.cache', '.git', 'file', '.mozilla', '.rnd', 'GUESS', 'Music', 'run.sh', '.finalshell', '.viminfy.tmp', '.config', 'docker-logspout-elk', 'Desktop', 'sed.txt', '100oush.sh', 'pid2.txt', '.cshrc', 'mynginx', '.bash_profile', 'etcd', 'sh.txt', 'oushu.sh', '.docker', '.viminfx.tmp', 'pid.sh', 'test', '.pycharm_helpers', 'user.sh', 'net', 'jiujiu.sh', '.dbus', 'sum100.sh', '.ssh', '.bashrc', 'LinEnum', 'sysinfo.sh', '.esd_auth', 'for100oushu.sh', 'pid1.txt', '.local', 'SuXinProject', 'phone.sh', '.ansible', '.viminfz.tmp', 'Documents', '.viminfo.tmp', 'study', '.ICEauthority', 'Pictures', 'for99.sh', '.bash_logout', '.pid.sh.swp', 'qiuhe.sh', 'pid.txt', '.viminfo', '.npm', 'fors00oushu.sh', '.pki', '99.sh', '.gitconfig', 'etcd-v3.2.10-linux-amd64', 'nohup.out', 'Public', 'user1.sh', 'diff.txt', '.Xauthority', '.virtualenvs', '.node_repl_history', '.pip', '.bash_history', 'Downloads', 'Videos', 'killpid.sh', 'Templates', 'daemon.json', 'beijing', 'dif', '.tcshrc', 'kill.sh', '.mysql_history', 'biao.txt', 'blog']&gt;&gt;&gt; os.path.getsize('./user.sh')299&gt;&gt;&gt; os.stat('./user.sh')posix.stat_result(st_mode=33261, st_ino=143152, st_dev=64769L, st_nlink=1, st_uid=0, st_gid=0, st_size=299, st_atime=1543135673, st_mtime=1542818209, st_ctime=1542818209)&gt;&gt;&gt; os.system('whoami')root0&gt;&gt;&gt; os.rename('99.sh','999.sh') os.getuid() #获取用户idos.getgid() #获取用户组idos.environ[‘环境变量名称’]=’环境变量值’ #设置环境变量os.environ[‘环境变量名称’] #获取环境变量os.getenv(‘环境变量名称’) #获取环境变量123456789&gt;&gt;&gt; os.getuid()0&gt;&gt;&gt; os.getgid()0&gt;&gt;&gt; os.environ['PYTHON']='/usr/local/bin'&gt;&gt;&gt; os.environ['PYTHON']'/usr/local/bin'&gt;&gt;&gt; os.getenv('PYTHON')'/usr/local/bin' os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) # 从上到下或从下到上遍历树来生成目录树中的文件名 参数 top - 以目录为根的每个目录产生3元组，即（dirpath，dirnames，filenames）。dirpath为目录的路径，为一个字符串。dirnames列出了目录路径下面所有存在的目录的名称。filenames列出了目录路径下面所有文件的名称。不明白的可以看下图 topdown - 如果可选参数topdown为True或未指定，则从上到下扫描目录。如果topdown设置为False，则会自下而上扫描目录，不懂的话可以看下面的代码就明白了 onerror - 这可能会显示错误以继续行走，或者引发异常以中止行走。 followlinks - 如果设置为true，则访问符号链接指向的目录。123456789101112131415161718192021222324252627&gt;&gt;&gt; for root, dirs, files in os.walk("."):... for name in dirs:... print(os.path.join(root,name))... ./shell编程./test./ftp./hexo&gt;&gt;&gt; for root, dirs, files in os.walk(".", topdown=False):... for name in files:... print(os.path.join(root, name))... ./shell编程/index.html./test/index.html./ftp/index.html./hexo/index.html./index.html&gt;&gt;&gt; for root, dirs, files in os.walk("."):... for name in files:... print(os.path.join(root, name))... ./index.html./shell编程/index.html./test/index.html./ftp/index.html./hexo/index.html]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http学习笔记]]></title>
    <url>%2F2018%2F10%2F29%2Fhttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[http:hypertext transfer protocol：超文本传输协议超文本：带有超级链接的链接超级链接：能够实现在不同的文档中跳转http/0.9版本：只支持纯文本的传输（带有超级连接）ASCII码&emsp;&emsp;HTML:hypertext mark&emsp;&emsp;language:超文本标记语言&emsp;&emsp;支持get方法，且不支持请求头 Browser:浏览器URI:uniform resourceindentifier:统一资源标识符URL：uniform resource locator：统一资源定位符&emsp;&emsp;统一：路径格式的统一&emsp;&emsp;protocal://address/to/resouce_pathweb资源：用URL标识，并且让用户客户端代理（浏览器）能够访问的文件HTML：把多种web资源整合成一个HTML文档，并能够让浏览器访问显示的一种语言http/1.0版本：&emsp;&emsp; 1.引入MIME机制（为了实现能够传输分文本信息）&emsp;&emsp; MIME:multi Internet mail extension：多用途互联网邮件交换协议，将非文本数据在传输之前重新编码为文本格式，接收方能够利用相反的方式将其重新还原为原来的格式，还能调用相应的应程序显示此文件&emsp;&emsp;扩展：SMTP:simple mail transfer protocol：简单邮件传输协议 &emsp;&emsp;2.请求与响应头域 &emsp;&emsp;3.响应对象以一个响应状态行开始 &emsp;&emsp;4.响应对象不止限于文本 &emsp;&emsp;5.开始支持客户端通过POST方法向web服务器提交数据，支持GET、HEAD、POST方法 &emsp;&emsp;6.支持长连接（但默认还是使用短连接）， &emsp;&emsp;7.缓存机制（加快速度），以及身份验证 动态网页：web服务器存储的文档是非HTML文档，而是动态语言，动态语言生成的脚本能够接受用户的参数后形成HTML文档，把生成的文档返回给客户端 http/1.1是目前使用最广泛的协议版本，在http1.0中使用长连接需要添加请求头Connection:Keep-Alive,而在http1.1默认支持长连接，除非特殊声明不支持（HTTP请求首部加上Connection:Close）,http1.1引入了许多关键优化：keepalive连接。chunked编码传输，字节范围请求，请求流水线等HTTP1.1协议中共定义了八种方法来表明Request-URI指定的资源的不同的操作方式：&emsp;&emsp;1. OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web发送’*’的请求来测试服务器的功能性&emsp;&emsp;2. HEAD：向服务器索要与GET请求相一致的响应，只不过想硬体将不会被返回，这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息&emsp;&emsp;3. GET：向特定的资源发出请求。注意：GET方法不应被用于产生“副作用”的操作中，例如在web app中，其中一个原因是GET可能会被网络爬虫等随意访问&emsp;&emsp;4. POST：向指定资源提交数据进行数据请求（例如提交表单或者上传文件）.数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改&emsp;&emsp;5. PUT：向指定资源位置上传其最新内容&emsp;&emsp;6. DELETE：请求服务器删除Request-URI所标识的资源&emsp;&emsp;7. TRACE：回显服务器收到的请求，主要用于测试和诊断&emsp;&emsp;8. CONNECT：http/1.1协议中预留给能够将连接改为管道方式的代理服务器 http/2.0是下一代http协议，目前应用还非常少，主要特点有： &emsp;&emsp;多路复用（二进制分帧）：在二进制分帧层上，http2.0将所有传输的信息分割为更小的消息和帧，并对他们采用二进制格式的编码 &emsp;&emsp;头部压缩：当一个客户端向相同服务器请求许多资源时，向来自同一个网页的图像，将会有大量的请求看上去几乎同样的，这就需要压缩技术对付这种几乎相同的信息 &emsp;&emsp;随时复位：http1.1一个缺点是当http信息有一定长度大小数据传输时，你不能方便地随时停止他，中断TCP连接的代价是昂贵的，使用http2的RST_STREAM将能够方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率 服务器端推流：server Push:客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用. 优先权和依赖：每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另一个流，优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突出抓住重点流 http报文：请求报文（http request）和响应报文（http response） &emsp;&emsp;请求报文语法：123&lt;method&gt;&lt;request-URI&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; &emsp;&emsp;响应报文语法：123 &lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headrers&gt;&lt;entity-body&gt; 响应报文的状态代码：&emsp;&emsp;1xx：纯信息，已经弃用&emsp;&emsp;200：“成功“类的信息&emsp;&emsp;301：永久重定向&emsp;&emsp;302：临时重定向&emsp;&emsp;304：浏览器缓存&emsp;&emsp;403：请求不到首页，权限被拒绝&emsp;&emsp;404：资源找不到&emsp;&emsp;500：服务器内部错误，程序代码错误&emsp;&emsp;502：找不到后端的错误&emsp;&emsp;504：请求超时 Web服务器处理并发连接请求的并发模型&emsp;&emsp;1.单线程web服多器(Single-threaded web servers):此种架构方式中,web服多器一次处理一个请求.结束后读取井处理下一个请求.在某请求处理辻程中,其它所有的清求将被阻塞,因此;在并发请求较多的场景中将会出现严重的性能问题（即一次只能处理一个请求） &emsp;&emsp;2.多进程/多线程web服灸器:此种架构方式中, web服多器生成多个进程或线程并行处理多个用戸请求,进程或线程可以按需或事先生成、有的web服务器应用程序为每个用戸请求生成一个単独的进程或线程来进行响应,不过, 一旦并发请求数量达到成千上万吋,多个同吋进行的进程或线程将会消耗大量的系統资源（即每个进程只能响应一个请求，并且一个进程对应一个线程） &emsp;&emsp;3.I/O多路复用web服努器:为了能够支持更多的并友用户清求,越来越多的web服努器正在采用多种复用的架构–即同歩监控所有的连接靖求的活动状态，当一个连接的状态发生改变时(如数据准各完毕或发生某错误)将为其执行一系列特定操作；在操作完成后此连接将重新变回暂时的稳定态并返回至打开的连接列表中，直到下次的状态改变，由于其多路复用的特性,进程或线程不会被空闲的连接所占用，因而可以提供高效的工作模弌.（这种架构可以理解为一个进程可以生成多个线程，每个请求交给一个线程程迸行处理)]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全学习网址]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[网络安全学习网址 http://www.sec-wiki.com/skill/安全技能(里面渗透逆向编程都有介绍)http://blog.knownsec.com/Knownsec_RD_Checklist/ 知道创宇研发技能表v3.0https://www.shentoushi.top/network 渗透师 （网络安全学习网址导航）https://www.anquanquan.info/ 安全圈info（网络安全学习导航网址） 综合学习平台： https://secquan.org 圈子社区https://github.com/cxf210/Scanners-Boxhttp://edu.gooann.com/ 谷安网校https://edu.aqniu.com/ 安全牛课堂http://www.jikexueyuan.com/ 极客学院http://www.hetianlab.com/ 合天http://www.moonsos.com/ 米安网http://www.ichunqiu.com/ i春秋http://www.honyaedu.com/ 红亚http://www.baimaoxueyuan.com/ 白帽学院http://www.simplexue.com/ctf/index 西普学院http://www.imooc.com/course/list 慕课http://www.secbox.cn/ 安全盒子http://www.freebuf.com/ freebufhttp://bobao.360.cn/ 360安全播报https://github.com/cxf210/Scanners-Box github上的资源库https://github.com/cxf210/dockerhttps://github.com/cxf210/fuzzdbhttps://github.com/cxf210/webshellgithub上的webshellhttp://drops.wooyun.org/ 乌云知识库http://wiki.wooyun.org/ WooYun WiKihttps://www.91ri.org/ 91rihttps://www.t00ls.NET/tools 土司https://bbs.77169.com/forum.php 华盟网http://www.ijiandao.com/ 爱尖刀http://www.secist.com/ 即刻安全http://www.secwk.com/article/index.html 威客众测http://bluereader.org/ 深蓝阅读http://www.shentou.org/ 黑客安全军火库http://netsecurity.51cto.com/ 51ctohttp://security.csdn.net/ csdnhttp://www.80sec.com/ 80sec teamhttps://security.alibaba.com/blog.htm?spm=0.0.0.0.knOqaI 阿里巴巴安全响应中心http://security.tencent.com/index.PHP/blog 腾讯安全应急响应中心博客http://security.360.cn/blog 360安全应急响应中心博客http://sec.baidu.com/index.php?research/list 百度安全应急响应中心博客 博客推荐 http://security.tencent.com/index.php/blog &gt; http://217.logdown.com/ 217https://laolisafe.com/ 大老李的博客http://mannix.top/ mannix的博客http://www.raosong.cc/ 折戟博客http://www.blue-lotus.net blue-lotus 蓝莲花http://blog.0ops.net/ 0opshttp://blog.amanhardikar.com/#homehttp://le4f.net/ e4fhttp://www.programlife.net/ 代码疯子http://www.hackdog.me/ redrain’bloghttp://www.syjzwjj.com/ 俊杰http://syclover.sinaapp.com/ 三叶草安全小组http://appleu0.sinaapp.com/ appleU0大大http://bl4ck.in/ tomato表哥http://www.sco4x0.com/ 4叔叔http://laterain.sinaapp.com/ 白神http://0nly3nd.sinaapp.com/ 0nly3ndhttp://hijacks.in/ LateRain’bloghttp://www.waitalone.cn/ 独自等待http://evilcos.me/ 余弦http://www.moonsec.com/ 暗月http://www.cnblogs.com/xuanhun/ 玄魂https://www.leavesongs.com/ 离别歌http://huaidan.org/ 鬼仔http://www.03sec.com/ sky的自留地http://joychou.org/ jc老师http://www.unhonker.com/ 90’s bloghttp://www1.taosay.net/ 道哥的黑板报http://blog.knownsec.com/ 知道创宇http://www.sadk.org/ 焠安http://www.cnseay.com/ seay’bloghttp://blog.aptsec.net/ AptSec Teamhttp://lcx.cc/ 网络安全研究中心http://www.kali.org.cn/ kali中文网http://xiao106347.blog.163.com/ xiao106347 kali折腾 渗透: http://www.wooyun.org/ 乌云http://bbs.blackbap.org/ 习科http://www.1937cn.net/ 1937http://forum.cnsec.org/ 暗组http://www.k33nteam.org/ keen teamhttp://forum.eviloctal.com/ 邪恶八进制http://www.evil0x.com/ 邪恶十六进制http://www.myhack58.com/ 黑吧安全吧http://www.cnhonkerarmy.com/ 中国红客红盟http://www.chinahacker.com/ 中国黑客联盟http://www.hxhack.com/ 华夏黑客联盟http://www.heikexiehui.com/ 中国黑客协会官网http://www.hackbase.com/ 黑基http://www.2cto.com/ 红黑联盟http://bbs.2cto.com/ 红黑联盟论坛http://www.hackwd.com/http://www.heishou.com.cn/ 黑手安全网https://www.sitedirsec.com/ 非安全中国网http://www.zatokasztuki.com/ 学生技术联盟 逆向： http://www.52pojie.cn/ 吾爱破解http://bbs.pediy.com/ 看雪论坛https://www.chinapyg.com/ 飘云阁论坛https://0x00sec.org/ 国外逆向论坛https://github.com/onethawt/reverseengineering-reading-list/blob/master/README.md 逆向工程阅读清单https://github.com/RPISEC/Malware/blob/master/README.md 恶意软件分析 编程： http://www.he11oworld.com/ hello wordhttp://www.w3school.com.cn/ w3schoolhttp://www.runoob.com/ 菜鸟http://www.51zxw.net/https://github.com/http://navisec-Git.qiniudn.com/http://c.biancheng.net/cpp/http://www.liaoxuefeng.com/http://www.php100.com/https://ruby-china.org/wikihttp://bbs.csdn.net/forums/Java/http://outofmemory.cn/tutorial/ 书籍： http://zhuanlan.zhihu.com/Evi1m0/19706178 Evi1m0: 书籍推荐http://www.douban.com/doulist/3339701/ 信息安全必读书单http://www.douban.com/doulist/1363865/ 信息安全经典书籍http://www.zhihu.com/question/21390646http://my.oschina.net/bluefly/blog/335409?utm_source=tuicool&amp;utm_medium=referralWeb安全核心书单连载《安全参考》http://www.douban.com/group/topic/72383272/(2013年第一期--2015年第一期)全集《书安》(更新中)http://www.secbox.cn/hacker/8205.html 书安SecBook第一期《icloud iOS安全大揭秘》http://www.secbox.cn/hacker/7366.html 书安SecBook第二期《信息安全攻防赛》渗透实战文章可以看看里的杨凡(http://blog.sina.com.cn/s/articlelist_1758675673_4_1.html)和法克文章（http://pan.baidu.com/share/link?shareid=249629&amp;uk=2198816663） 工具： 链接：https://pan.baidu.com/s/1tt9O4etSxkFzPsRCamOInA提取码：dt8o 个人收集的一些ctf工具包https://github.com/zardus/ctf-tools github上的ctf工具http://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=388015 吾爱破解工具包http://down.52pojie.cn/ 爱盘 – 在线破解工具包，教程http://www.52pojie.cn/thread-341238-1-1.html 吾爱破解论坛专用破解虚拟机ctf常用工具包请看http://tieba.baidu.com/p/3933947157里面群文件 其他 http://www.zhihu.com/topic/19558642 黑客知乎话题http://www.zhihu.com/topic/20011446 ctf知乎话题http://www.zhihu.com/topic/19561983 信息安全知乎话题http://zhuanlan.zhihu.com/evilcos/19961466 余弦知乎专栏 CTF方面 http://blog.idf.cn/2015/02/ctf-field-guidehttp://tieba.baidu.com/p/3933947157 ctf大全https://ctftime.org/event/list/upcoming 各种CTF赛事预告(ps:国内各个高校或企业举办的比赛请进http://tieba.baidu.com/p/3933947157里面的群) 平时ctf练习ctf逆向: https://ctf.pediy.com/ 看雪ctfhttp://reversing.kr/http://pwnable.kr/http://exploit-exercises.com/http://overthewire.orghttp://security.cs.rpi.edu/courses/binexp-spring2015/ bin 干货区http://www.52pojie.cn/forum-67-1.html 『2014CrackMe大赛』 SQL: https://github.com/Audi-1/sqli-labshttp://redtiger.labs.overthewire.org/ ctf XSS: http://prompt.ml/http://xss.pkav.net/xss/http://www.doscn.org/xss/http://xss-quiz.int21h.jp/http://escape.alf.nu/https://xss-game.appspot.com/ 谷歌的xss游戏 密码学：http://cryptopals.com/ ctf综合练习：http://ctf.nuptsast.com/login 南邮大学ctfhttp://hackinglab.cn/ 网络信息安全攻防学习平台https://www.91ctf.com/session 安恒竞赛平台http://ctf.bugku.com/new bugkuctf练习平台http://captf.com/ ctf题目http://cafebabe.cc/nazo/ 脑洞开发，与ctf只有那么一点关系，有85关了http://1111.segmentfault.com/ 光棍节程序员闯关秀http://www.helloisa.com/test/http://www.fj543.com/hack/ 黑客丛林之旅http://monyer.com/game/game1/ 梦之光芒的小游戏http://oj.xctf.org.cn/ XCTF_OJ练习平台http://hackgame.blackbap.org/ 习科黑客游戏http://ctf.3sec.cn/ Jlu.CTFhttp://www.baimaoxueyuan.com/ctf 白帽学院ctf挑战赛http://www.ichunqiu.com/tiaozhans i春秋ctf挑战http://ctf.idf.cn/ idf 实验室http://www.dvwa.co.uk/ DVWAhttp://ctf.moonsos.com/pentest/index.php 米安网ctfhttp://www.hetianlab.com/CTFrace.html 合天ctfhttp://www.shiyanbar.com/ctf/index 实验吧(前名西普学院）http://hkyx.myhack58.com/ 黑吧安全网-红客闯关游戏http://202.108.211.5/ 实训竞赛系统 国外比较好的几个综合练习平台 https://ctf365.com/https://hack.me/s/https://ringzer0ctf.com/challengeshttps://www.hackergateway.com/http://challengeland.co/http://www.hackertest.net/http://www.wechall.nethttps://www.vulnhub.com/http://insight-labs.org/http://wargame.kr/https://ctflearn.com/http://canyouhack.it/https://pentest.training/index.phphttp://hackit.sinaapp.com/http://webhacking.kr/http://fun.coolshell.cn/http://ringzer0team.com/challengehttps://backdoor.sdslabs.co/https://www.enigmagroup.org/pages/challengeshttp://overthewire.org/wargames/natas/natas2.htmlhttp://smashthestack.org/ 漏洞利用练习网站 ctf writeup(WP): 直接百度:writeup(一边看一边总结，有道笔记，印象笔记什么的，最好能复现)http://drops.wooyun.org/?s=writeup&amp;submit=%E6%90%9C%E7%B4%A2http://bobao.360.cn/ctf/https://github.com/ctfs/ 各种 writeuphttp://sec.yka.me/ CTF Writeup Summaryhttps://ctf-team.vulnhub.com/ Write Upshttp://hebin.me/https://blog.csdn.net/gyt478922579/article/details/53204891?locationNum=11&amp;fps=1https://blog.csdn.net/xuqi7/article/details/51635360]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos系统7的ftp版本创建目录和匿名用户登录的测试]]></title>
    <url>%2F2018%2F09%2F13%2Fcentos%E7%B3%BB%E7%BB%9F7%E7%9A%84ftp%E7%89%88%E6%9C%AC%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E5%92%8C%E5%8C%BF%E5%90%8D%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[centos6系统使用的ftp是2.0以上的版本，而centos7使用的是3.0.2版本 首先说一下ftp使用匿名用户创建目录在centos7下只能在pub下创建文件夹，而且pub用户属主必须是ftp或者将pub目录授予777的权限，也就是说ftp用户在pub目录下必须具有写的权限。在这之前需要确保配置文件这几个选项为YES，这几个选项在配置文件里都是默认开启的，还有selinux要处于Permissive状态123anon_mkdir_write_enable=YESanon_upload_enable=YESanonymous_enable=YES 还有centos7下拒绝访问ftp服务的权限首先，ftp的访问跟ftp/pub的权限是没关系的，在正常情况下，授予ftp目录777的权限，是拒绝用户访问的如果将ftp目录的属主和属组都修改成ftp用户，将ftp目录的权限修改回755，也是不能访问的将配置文件的umask修改成000，并且重启服务，还是不能访问，但是如果我将ftp的目录的属主和属组都修改成ftp，而ftp的目录权限修改成557，那么ftp服务就可以正常访问了当我把ftp的属主和属组又修改成root之后，ftp服务又不能访问了我再把ftp的属主和属组都修改成ftp,,ftp服务还是可以正常的访问如果我再将ftp的目录权限修改成335，而属主和属组都是root，那么ftp也是可以访问的保持权限不变，而属主和属组改为ftp，那么ftp服务还是不能访问我再修改ftp目录的权限为445，将ftp目录的属主和属组都改为root，ftp服务还是可以访问的ftp目录的权限不变，修改ftp目录的属主和属组为ftp,ftp是可以进行访问的这里属主和属组都不改变，分别修改ftp目录的权限为665和225，结果ftp服务都不能访问也就是说不能给ftp用户写的权限，否则不能访问ftp。那如果我修改一下默认目录试试呢，我将ftp默认访问路径修改成/var/test，再次进行测试发现test目录的权限也是不能有写权限，否则不能访问因此，我们可以得出结论：访问ftp服务的匿名用户不能有写权限，这也就是为什么ftp目录下匿名用户不能创建子目录的原因]]></content>
      <categories>
        <category>ftp</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程之条件测试]]></title>
    <url>%2F2018%2F08%2F18%2Fshell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于条件测试命令可以使用man test命令查看 条件测试语句语法1.test 测试语句2.[ 测试语句 ]3.[[ 测试语句 ]]4.((测试语句))其中1和2除了语法不一样，功能基本是一样的，而第3种语法他可以使用通配符进行匹配，第四种语法除了用于整数的比较，更多的还是进行一些整数的运算，不过平时经常用到的还是第2、3种语法结构。 条件测试类型 文件测试 数值测试 字符串测试 逻辑测试文件测试格式：1.test 文件测试符 file2.[ 文件测试符 file ] #中括号的两边都需要有空格3.[[ 文件测试符 file ]] #中括号两边需要有空格常用文件测试操作符：123456789101112-b: 文件是否存在，并且为块文件-c：文件是否存在，并且为字符文件-d: 文件是否存在，并且为一个目录（在linux下,万物皆为文件）-e: 文件是否存在-f: 文件是否存在，并且为普通文件-s: 文件是否存在，并且文件大小大于零-L: 文件是否存在，并且为链接文件-r: 文件是否存在，并且文件可读-w: 文件是否存在，并且文件可写-x: 文件是否存在，并且文件可执行file1 -nt file2 文件1是否比文件2新(文件新旧是按照文件修改时间来区分的)file1 -ot file2 文件1是否比文件2旧 实例：1234567891011[root@docker ~]# touch wanger #新建一个普通文件[root@docker ~]# test -f wanger &amp;&amp; echo 0 || echo 10 #测试文件是否是普通文件，如果是输出0，否则输出1[root@docker ~]# [ -d wanger ] &amp;&amp; echo 0 || echo 11 #测试文件是否是一个目录，如果是输出0，否则输出1[root@docker ~]# touch wangerxiao 创建一个普通文件wangerxiao[root@docker ~]# test wanger -nt wangerxiao &amp;&amp; echo 0 || echo 11 #比较wanger是否比wangerxiao新，如果为真输出0，否则输出1[root@docker ~]# [ wanger -ot wangerxiao ] &amp;&amp; echo 0 || echo 10 #比较wanger是否比wangerxiao旧，如果为真输出0，否则输出1 字符串测试：格式： test 字符串测试符 string [ 字符串测试符 string ] [[ 字符串测试符 string ]]常用字符串测试操作符：1234-z string :字符串长度是否为0-n string :字符串长度是否不为0string1 = string2 :string1和string2是否相等string1 != string2 :string1和string2是否不相等 实例：123456789[root@docker ~]# name=wanger #定义一个变量[root@docker ~]# [ -z $name ] &amp;&amp; echo 0 || echo 11 #判断字符串是否为空，为空则返回0，否则返回1[root@docker ~]# test -n $name &amp;&amp; echo 0 || echo 10 #判断字符串是否不为空，如果是则返回0，否则返回1[root@docker ~]# [ $name != &quot;wanger&quot; ] &amp;&amp; echo 0 || echo 11 #判断变量是否不等于”wanger”，如果是返回0,否则返回1[root@docker ~]# test $name = &quot;wanger&quot; &amp;&amp; echo 0 || echo 10 #判断变量是否等于”wanger”,如果是返回0，否则返回1 数值测试：格式：test num1 数值测试操作符 num2[ num1 数值测试操作符 num2 ][[ num 数值测试操作符 num2 ]]((num1数值测试操作符num2)) 常用数值测试操作符：123456num1 -eq num2 : 数字1是否等于数字2num1 -ge num2 : 数字1是否大于等于数字2num1 -gt num2 : 数字1是否大于数字2num1 -le num2 : 数字1是否小于等于数字2num1 -lt num2 : 数字1是否小于数字2num1 -ne num2 : 数字1是否不等于数字2 注意：以上几种操作符不能用在(())格式中，在(())中应使用”&lt; &gt; = != &gt;= &lt;=”比较符号来进行数值的比较 实例：123456789[root@docker ~]# test 6 -le 5 &amp;&amp; echo 0 ||echo 10 #判断6是否小于等于5，如果是返回0，否则返回1[2]+ Done test 64 -gt 63[root@docker ~]# [ 6 -gt 5 ]&amp;&amp; echo 0 || echo 10 #判断6是否大于5，如果大于返回0，否则返回1[root@docker ~]# [[ 6 = 5 ]]&amp;&amp; echo 0 || echo 11 #判断6是否等于5，如果等于返回0，否则返回1[root@docker ~]# ((5!=6))&amp;&amp;echo 0 ||echo 10 #判断5是否等于6，如果不等于返回0，等于则返回1 逻辑运算符：123-a : 相当于&amp;&amp;，表示逻辑与，两端条件都为真，结果为真-o : 相当于||,表示逻辑或，两端条件只要有一个为真，结果就为真！: 逻辑非，两端相反结果为真 实例：1234567test=”123” #定义test变量[root@docker ~]# [ ! -z $test -o $test = &quot;123&quot; ] &amp;&amp;echo 0 || echo 10 #判断test变量是否不为空或者是否等于123，如果是返回0，在[]格式中只能使用-o和-a，而不能用&amp;&amp;和||[root@docker ~]# test -z $test &amp;&amp; test $test = &quot;123&quot; &amp;&amp;echo 0 ||echo 11 #判断test变量是否为空并且test变量是否等于123，如果是返回0[root@docker ~]# [[ -z $test || $test = &quot;123&quot; ]] &amp;&amp;echo 0 ||echo 10 #判断test变量是否为空或者test变量是否等于123，如果是返回0]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程循环脚本]]></title>
    <url>%2F2018%2F08%2F18%2Fshell%E7%BC%96%E7%A8%8B%E5%BE%AA%E7%8E%AF%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[求从1加到100的和使用for循环求和：123456#!/bin/bashdeclare -i sum=0for ((i=1;i&lt;=100;i++));do let sum+=$idoneecho &quot;sum=$sum&quot; 使用until循环求和：123456789#!/bin/bashi=1sum=0until [ $i -gt 100 ];do let sum+=$i let i++doneecho &quot;sum is:$sum&quot; 使用while循环求和：123456789#!/bin/bashi=1sum=0while [ $i -le 100 ];do let sum+=$i let i++doneecho &quot;sum is:$sum&quot; 求100以内的偶数之和使用for循环求和：1234567891011#!/bin/bashi=0sum=0for i in `seq 100` ;do if [ $[$i%2] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is:$sum&quot; 使用while循环求和：123456789101112#!/bin/bashi=0sum=0while [ $i -le 100 ];do let i++ if [ $[$i%2] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is: $sum&quot; 使用until循环求和：123456789101112#!/bin/bashi=0sum=0until [ $i -gt 100 ];do let i++ if [ $[ $i%2 ] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is: $sum&quot; 编写一个九九乘法表使用for循环：123456789#!/bin/bash#for i in `seq 9`;dofor ((j=1;j&lt;=9;j++));do for ((i=1;i&lt;=j;i++));do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; done echodone 使用while循环：12345678910111213#!/bin/bashi=1j=1while[ $j -le 9 ];do while [ $i -le $j ];do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; let i++ done echo let i=1 let j++done 使用until循环：12345678910111213#!/bin/bashi=1j=1until [ $j -gt 9 ];do until [ $i -gt $j ];do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; let i++ done echo let i=1 let j++done 通过脚本判断用户是否登入系统，如果没有，则每10秒循环一次使用while循环：1234567#!/bin/bashread -p &quot;pls input a username: &quot; usernamewhile ! `who |grep &quot;^$username&quot; &amp;&gt; /dev/null`;do sleep 10doneecho &quot;`date +%F-%H:%M:%S` $username logged on&quot;&gt;&gt;/tmp/user.log 使用case循环来获取系统信息1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bashcat &lt;&lt;EOF1) show cpu information;2) show memory information;3) show disk information;4) quitEOFcpu_info()&#123; lscpu &#125;mem_info()&#123; cat /proc/meminfo &#125;disk_info()&#123; fdisk -l &#125;quit()&#123; echo &quot;quit&quot; exit 0 &#125; read -p &quot;pls input a num: &quot; numif [ $num -ne 1 -a $num -ne 2 -a $num -ne 3 -a $num -ne 4 ];then read -p &quot;pls input a num again: &quot; numficase &quot;$num&quot; in 1) cpu_info ;;2) mem_info ;;3) disk_info ;;4) quitesac]]></content>
      <categories>
        <category>shell编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题第一种 markdown最高可以设置六级标题,前面#号的数量代表标题的等级,#号后面要带一个空格123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 演示 一级标题二级标题三级标题四级标题五级标题六级标题第二种 这种只能表示一级和二级标题,=和-的数量没有限制，只要大于一就行1234一级标题=======二级标题------ 演示 一级标题二级标题2.文本样式1234**加粗***斜体* 或者 _斜体_***加粗斜体***~~删除线~~ 演示加粗斜体加粗斜体删除线 3.列表无序列表无序列表可以有三种写法,使用*或+或- :1234567891011121314使用 * ：* 无序列表1* 无序列表2* 无序列表3使用 + ：+ 无序列表4+ 无序列表5+ 无序列表6使用 - ：- 无序列表7- 无序列表8- 无序列表9 演示使用 * ： 无序列表1 无序列表2 无序列表3 使用 + ： 无序列表4 无序列表5 无序列表6 使用 - ： 无序列表7 无序列表8 无序列表9有序列表有序列表就是在前面加数字而不是用符号1231. 有序列表12. 有序列表23. 有序列表3 演示 有序列表1 有序列表2 有序列表34.引用引用的格式很简单,在引用的文字前面加上&gt;就行了12&gt; 为人民服务&gt; ——毛主席 演示 为人民服务 ——毛主席 5.代码块比较短的或是单行的代码可以使用反引号包裹,若是有多行的代码要使用3个反引号,这里为了转义我用\将反引号隔开，顺便说一下,如果不想让一些符号用作markdown语法,可用\进行转义。123456`短的或者单行代码``\`` 多行代码&#123; print ‘人生苦短，我用Python’ &#125;`\`` 演示短的或者单行代码123多行代码&#123; print ‘人生苦短，我用Python’ &#125; 6.表格在markdown里使用表格有点麻烦，使用|来分隔不同的单元格，使用-来分隔表头和其他行，使用:来设置表格的对齐方式:--- 表示左对齐,不加:也表示左对齐:--: 表示居中对齐---: 表示右对齐12345|name|age|sex||:-----|:--:|----:||wanger|23 |nan ||lisi |20 |nv ||wangwu|22 |nan | 演示 name age sex wanger 23 nan lisi 20 nv wangwu 22 nan 7.分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，同时需要在分隔线的上面空一行。123---___*** 演示 8.超链接与图片超链接与图片格式的最大区别就是图片格式多一个’!’，图片的title和链接的title表示你的鼠标指向图片或者链接描述的时候出现的内容,title与图片地址和链接地址之间有空格,title属性可以不加。 图片![图片描述](图片地址 &quot;title&quot;) 链接[链接描述](链接地址 &quot;title&quot;)12![微信公众号](/uploads/wechat-qcode.jpg &quot;微信公众号&quot;)[个人博客](https://wahaha5354.github.io &quot;个人博客&quot;) 演示个人博客]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题的个性化设置]]></title>
    <url>%2F2018%2F08%2F09%2Fnext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[因为hexo博客使用的markdown语法，之前并没有接触过markdown语法，所以第一次写博客只能参考markdown语法的用法来写 设置hexo的头像之前参照了网上修改的方法老是出现报错，折腾了两天还是不行，后来在修改网站图标的时候才知道是因为我配置文件格式写错了，网上的很多方法都是在主题的配置文件里改，但我改了并没有生效，也许是姿势有问题，后来在主题的配置文件里修改竟然生效了，在配置文件里搜索’Sidebar Avatar’，找到如下字段：123456# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg 在url: 后面加上头像的存放地址，我的头像放在了站点目录/source/images/目录下，修改完配置后执行命令:hexo cleanhexo ghexo d 站内搜索刚开始想用Swiftype来着，后来才知道Swiftype在去年就停止免费服务了，又想着去用Algolia，但我实在太笨，找不到地址在哪里，网站访问的也很慢，于是准备用hexo自带的Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 具体可以参考官方的文档Next使用文档目前我的博客评论用的是来必力，分享用的是Add This,站内搜索用的是local search，感觉用起来还是挺不错的]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[后面没有了，这是最早的一篇博客了 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F05%2Ftest%2F</url>
    <content type="text"><![CDATA[hello wanger]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
