<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shell编程之条件测试]]></title>
    <url>%2F2018%2F08%2F18%2Fshell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于条件测试命令可以使用man test命令查看 条件测试语句语法1.test 测试语句2.[ 测试语句 ]3.[[ 测试语句 ]]4.((测试语句))其中1和2除了语法不一样，功能基本是一样的，而第3种语法他可以使用通配符进行匹配，第四种语法除了用于整数的比较，更多的还是进行一些整数的运算，不过平时经常用到的还是第2、3种语法结构。 条件测试类型 文件测试 数值测试 字符串测试 逻辑测试文件测试格式：1.test 文件测试符 file2.[ 文件测试符 file ] #中括号的两边都需要有空格3.[[ 文件测试符 file ]] #中括号两边需要有空格常用文件测试操作符：123456789101112-b: 文件是否存在，并且为块文件-c：文件是否存在，并且为字符文件-d: 文件是否存在，并且为一个目录（在linux下,万物皆为文件）-e: 文件是否存在-f: 文件是否存在，并且为普通文件-s: 文件是否存在，并且文件大小大于零-L: 文件是否存在，并且为链接文件-r: 文件是否存在，并且文件可读-w: 文件是否存在，并且文件可写-x: 文件是否存在，并且文件可执行file1 -nt file2 文件1是否比文件2新(文件新旧是按照文件修改时间来区分的)file1 -ot file2 文件1是否比文件2旧 实例：1234567891011[root@docker ~]# touch wanger #新建一个普通文件[root@docker ~]# test -f wanger &amp;&amp; echo 0 || echo 10 #测试文件是否是普通文件，如果是输出0，否则输出1[root@docker ~]# [ -d wanger ] &amp;&amp; echo 0 || echo 11 #测试文件是否是一个目录，如果是输出0，否则输出1[root@docker ~]# touch wangerxiao 创建一个普通文件wangerxiao[root@docker ~]# test wanger -nt wangerxiao &amp;&amp; echo 0 || echo 11 #比较wanger是否比wangerxiao新，如果为真输出0，否则输出1[root@docker ~]# [ wanger -ot wangerxiao ] &amp;&amp; echo 0 || echo 10 #比较wanger是否比wangerxiao旧，如果为真输出0，否则输出1 字符串测试：格式： test 字符串测试符 string [ 字符串测试符 string ] [[ 字符串测试符 string ]]常用字符串测试操作符：1234-z string :字符串长度是否为0-n string :字符串长度是否不为0string1 = string2 :string1和string2是否相等string1 != string2 :string1和string2是否不相等 实例：123456789[root@docker ~]# name=wanger #定义一个变量[root@docker ~]# [ -z $name ] &amp;&amp; echo 0 || echo 11 #判断字符串是否为空，为空则返回0，否则返回1[root@docker ~]# test -n $name &amp;&amp; echo 0 || echo 10 #判断字符串是否不为空，如果是则返回0，否则返回1[root@docker ~]# [ $name != &quot;wanger&quot; ] &amp;&amp; echo 0 || echo 11 #判断变量是否不等于”wanger”，如果是返回0,否则返回1[root@docker ~]# test $name = &quot;wanger&quot; &amp;&amp; echo 0 || echo 10 #判断变量是否等于”wanger”,如果是返回0，否则返回1 数值测试：格式：test num1 数值测试操作符 num2[ num1 数值测试操作符 num2 ][[ num 数值测试操作符 num2 ]]((num1数值测试操作符num2)) 常用数值测试操作符：123456num1 -eq num2 : 数字1是否等于数字2num1 -ge num2 : 数字1是否大于等于数字2num1 -gt num2 : 数字1是否大于数字2num1 -le num2 : 数字1是否小于等于数字2num1 -lt num2 : 数字1是否小于数字2num1 -ne num2 : 数字1是否不等于数字2 注意：以上几种操作符不能用在(())格式中，在(())中应使用”&lt; &gt; = != &gt;= &lt;=”比较符号来进行数值的比较 实例：123456789[root@docker ~]# test 6 -le 5 &amp;&amp; echo 0 ||echo 10 #判断6是否小于等于5，如果是返回0，否则返回1[2]+ Done test 64 -gt 63[root@docker ~]# [ 6 -gt 5 ]&amp;&amp; echo 0 || echo 10 #判断6是否大于5，如果大于返回0，否则返回1[root@docker ~]# [[ 6 = 5 ]]&amp;&amp; echo 0 || echo 11 #判断6是否等于5，如果等于返回0，否则返回1[root@docker ~]# ((5!=6))&amp;&amp;echo 0 ||echo 10 #判断5是否等于6，如果不等于返回0，等于则返回1 逻辑运算符：123-a : 相当于&amp;&amp;，表示逻辑与，两端条件都为真，结果为真-o : 相当于||,表示逻辑或，两端条件只要有一个为真，结果就为真！: 逻辑非，两端相反结果为真 实例：1234567test=”123” #定义test变量[root@docker ~]# [ ! -z $test -o $test = &quot;123&quot; ] &amp;&amp;echo 0 || echo 10 #判断test变量是否不为空或者是否等于123，如果是返回0，在[]格式中只能使用-o和-a，而不能用&amp;&amp;和||[root@docker ~]# test -z $test &amp;&amp; test $test = &quot;123&quot; &amp;&amp;echo 0 ||echo 11 #判断test变量是否为空并且test变量是否等于123，如果是返回0[root@docker ~]# [[ -z $test || $test = &quot;123&quot; ]] &amp;&amp;echo 0 ||echo 10 #判断test变量是否为空或者test变量是否等于123，如果是返回0]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程循环脚本]]></title>
    <url>%2F2018%2F08%2F18%2Fshell%E7%BC%96%E7%A8%8B%E5%BE%AA%E7%8E%AF%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[求从1加到100的和使用for循环求和：123456#!/bin/bashdeclare -i sum=0for ((i=1;i&lt;=100;i++));do let sum+=$idoneecho &quot;sum=$sum&quot; 使用until循环求和：123456789#!/bin/bashi=1sum=0until [ $i -gt 100 ];do let sum+=$i let i++doneecho &quot;sum is:$sum&quot; 使用while循环求和：123456789#!/bin/bashi=1sum=0while [ $i -le 100 ];do let sum+=$i let i++doneecho &quot;sum is:$sum&quot; 求100以内的偶数之和使用for循环求和：1234567891011#!/bin/bashi=0sum=0for i in `seq 100` ;do if [ $[$i%2] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is:$sum&quot; 使用while循环求和：123456789101112#!/bin/bashi=0sum=0while [ $i -le 100 ];do let i++ if [ $[$i%2] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is: $sum&quot; 使用until循环求和：123456789101112#!/bin/bashi=0sum=0until [ $i -gt 100 ];do let i++ if [ $[ $i%2 ] -eq 1 ];then continue fi let sum+=$idoneecho &quot;sum is: $sum&quot; 编写一个九九乘法表使用for循环：123456789#!/bin/bash#for i in `seq 9`;dofor ((j=1;j&lt;=9;j++));do for ((i=1;i&lt;=j;i++));do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; done echodone 使用while循环：12345678910111213#!/bin/bashi=1j=1while[ $j -le 9 ];do while [ $i -le $j ];do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; let i++ done echo let i=1 let j++done 使用until循环：12345678910111213#!/bin/bashi=1j=1until [ $j -gt 9 ];do until [ $i -gt $j ];do echo -ne &quot;$i*$j=$(($i*$j))\t&quot; let i++ done echo let i=1 let j++done 通过脚本判断用户是否登入系统，如果没有，则每10秒循环一次使用while循环：1234567#!/bin/bashread -p &quot;pls input a username: &quot; usernamewhile ! `who |grep &quot;^$username&quot; &amp;&gt; /dev/null`;do sleep 10doneecho &quot;`date +%F-%H:%M:%S` $username logged on&quot;&gt;&gt;/tmp/user.log 使用case循环来获取系统信息1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bashcat &lt;&lt;EOF1) show cpu information;2) show memory information;3) show disk information;4) quitEOFcpu_info()&#123; lscpu &#125;mem_info()&#123; cat /proc/meminfo &#125;disk_info()&#123; fdisk -l &#125;quit()&#123; echo &quot;quit&quot; exit 0 &#125; read -p &quot;pls input a num: &quot; numif [ $num -ne 1 -a $num -ne 2 -a $num -ne 3 -a $num -ne 4 ];then read -p &quot;pls input a num again: &quot; numficase &quot;$num&quot; in 1) cpu_info ;;2) mem_info ;;3) disk_info ;;4) quitesac]]></content>
      <categories>
        <category>shell编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题第一种 markdown最高可以设置六级标题,前面#号的数量代表标题的等级,#号后面要带一个空格123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 演示 一级标题二级标题三级标题四级标题五级标题六级标题第二种 这种只能表示一级和二级标题,=和-的数量没有限制，只要大于一就行1234一级标题=======二级标题------ 演示 一级标题二级标题2.文本样式1234**加粗***斜体* 或者 _斜体_***加粗斜体***~~删除线~~ 演示加粗斜体加粗斜体删除线 3.列表无序列表无序列表可以有三种写法,使用*或+或- :1234567891011121314使用 * ：* 无序列表1* 无序列表2* 无序列表3使用 + ：+ 无序列表4+ 无序列表5+ 无序列表6使用 - ：- 无序列表7- 无序列表8- 无序列表9 演示使用 * ： 无序列表1 无序列表2 无序列表3 使用 + ： 无序列表4 无序列表5 无序列表6 使用 - ： 无序列表7 无序列表8 无序列表9有序列表有序列表就是在前面加数字而不是用符号1231. 有序列表12. 有序列表23. 有序列表3 演示 有序列表1 有序列表2 有序列表34.引用引用的格式很简单,在引用的文字前面加上&gt;就行了12&gt; 为人民服务&gt; ——毛主席 演示 为人民服务 ——毛主席 5.代码块比较短的或是单行的代码可以使用反引号包裹,若是有多行的代码要使用3个反引号,这里为了转义我用\将反引号隔开，顺便说一下,如果不想让一些符号用作markdown语法,可用\进行转义。123456`短的或者单行代码``\`` 多行代码&#123; print ‘人生苦短，我用Python’ &#125;`\`` 演示短的或者单行代码123多行代码&#123; print ‘人生苦短，我用Python’ &#125; 6.表格在markdown里使用表格有点麻烦，使用|来分隔不同的单元格，使用-来分隔表头和其他行，使用:来设置表格的对齐方式:--- 表示左对齐,不加:也表示左对齐:--: 表示居中对齐---: 表示右对齐12345|name|age|sex||:-----|:--:|----:||wanger|23 |nan ||lisi |20 |nv ||wangwu|22 |nan | 演示 name age sex wanger 23 nan lisi 20 nv wangwu 22 nan 7.分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，同时需要在分隔线的上面空一行。123---___*** 演示 8.超链接与图片超链接与图片格式的最大区别就是图片格式多一个’!’，图片的title和链接的title表示你的鼠标指向图片或者链接描述的时候出现的内容,title与图片地址和链接地址之间有空格,title属性可以不加。 图片![图片描述](图片地址 &quot;title&quot;) 链接[链接描述](链接地址 &quot;title&quot;)12![微信公众号](/uploads/wechat-qcode.jpg &quot;微信公众号&quot;)[个人博客](https://wahaha5354.github.io &quot;个人博客&quot;) 演示个人博客]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题的个性化设置]]></title>
    <url>%2F2018%2F08%2F09%2Fnext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[因为hexo博客使用的markdown语法，之前并没有接触过markdown语法，所以第一次写博客只能参考markdown语法的用法来写 设置hexo的头像之前参照了网上修改的方法老是出现报错，折腾了两天还是不行，后来在修改网站图标的时候才知道是因为我配置文件格式写错了，网上的很多方法都是在主题的配置文件里改，但我改了并没有生效，也许是姿势有问题，后来在主题的配置文件里修改竟然生效了，在配置文件里搜索’Sidebar Avatar’，找到如下字段：123456# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg 在url: 后面加上头像的存放地址，我的头像放在了站点目录/source/images/目录下，修改完配置后执行命令:hexo cleanhexo ghexo d 站内搜索刚开始想用Swiftype来着，后来才知道Swiftype在去年就停止免费服务了，又想着去用Algolia，但我实在太笨，找不到地址在哪里，网站访问的也很慢，于是准备用hexo自带的Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 具体可以参考官方的文档Next使用文档目前我的博客评论用的是来必力，分享用的是Add This,站内搜索用的是local search，感觉用起来还是挺不错的]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[后面没有了，这是最早的一篇博客了 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F05%2Ftest%2F</url>
    <content type="text"><![CDATA[hello wanger]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
